# Tests for getUniqueTrials ----------------------------------------------------

test_that("getUniqueTrials: combines scenarios and returns unique responder/subject/go rows", {
  set.seed(123)
  
  # Two realistic scenarios, each with 2 cohorts and 2 trials
  scen1 <- getScenario(
    n_subjects     = c(10, 10),
    response_rates = c(0.1, 0.2),
    n_trials       = 2
  )
  
  scen2 <- getScenario(
    n_subjects     = c(10, 10),
    response_rates = c(0.3, 0.4),
    n_trials       = 2
  )
  
  scenario_list <- list(
    scenario_1 = scen1,
    scenario_2 = scen2
  )
  class(scenario_list) <- "scenario_list"
  
  out <- getUniqueTrials(scenario_list)
  
  # responders (2) + subjects (2) + go_flag (1) = 5 columns
  expect_equal(ncol(out), 5)
  
  out_df <- as.data.frame(out)
  # no duplicate rows
  expect_equal(nrow(out_df), nrow(unique(out_df)))
  
  # Build the same "combined" matrix as getUniqueTrials internally
  all_resp <- do.call(rbind, lapply(scenario_list, function(x) x$n_responders))
  all_subj <- do.call(rbind, lapply(scenario_list, function(x) x$n_subjects))
  all_go   <- do.call(
    rbind,
    lapply(scenario_list, function(x) x$previous_analyses$go_decisions)
  )[, 1]
  
  combined <- cbind(all_resp, all_subj, go_flag = all_go)
  exp_df   <- as.data.frame(unique(combined))
  
  # Compare sorted versions, ignoring names
  out_ord <- out_df[do.call(order, out_df), , drop = FALSE]
  exp_ord <- exp_df[do.call(order, exp_df), , drop = FALSE]
  
  expect_equal(
    unname(as.matrix(out_ord)),
    unname(as.matrix(exp_ord))
  )
})



# Tests for mapUniqueTrials ----------------------------------------------------

test_that("mapUniqueTrials: without previous trials, maps unique trial quantiles back per scenario", {
  foreach::registerDoSEQ()
  set.seed(123)
  
  # One scenario, 2 cohorts, 2 trials
  scen <- getScenario(
    n_subjects     = c(10, 10),
    response_rates = c(0.1, 0.2),
    n_trials       = 2
  )
  
  # Drop previous_analyses to represent "no applicable previous trials"
  scen$previous_analyses <- NULL
  
  scenario_list <- list(scenario_1 = scen)
  class(scenario_list) <- "scenario_list"
  
  # trials_unique_calc: use all (r, n) rows, same structure as in the function
  trials_unique_calc <- cbind(scen$n_responders, scen$n_subjects)
  
  quantiles <- c(0.025, 0.5, 0.975)
  j_data    <- list(a = 1, b = 1)  # Beta(1,1) prior for pooled
  
  # Quantiles per trial, as getPostQuantiles would compute for each (r, n) row
  method_quantiles_list <- list(
    pooled = getPostQuantiles(
      method_name       = "pooled",
      quantiles         = quantiles,
      scenario_data     = list(
        n_subjects   = scen$n_subjects,
        n_responders = scen$n_responders
      ),
      calc_differences  = NULL,
      j_parameters      = NULL,
      j_model_file      = NULL,
      j_data            = j_data,
      n_mcmc_iterations = 1000,
      save_path         = NULL,
      save_trial        = NULL
    )
  )
  
  out <- mapUniqueTrials(
    scenario_list              = scenario_list,
    method_quantiles_list      = method_quantiles_list,
    trials_unique_calc         = trials_unique_calc,
    applicable_previous_trials = FALSE
  )
  
  expect_type(out, "list")
  expect_identical(names(out), "scenario_1")
  
  scen1 <- out[["scenario_1"]]
  expect_true(is.list(scen1))
  expect_true("pooled" %in% names(scen1))
  
  # For this setup: all trials are "new" (no previous), so each trial’s
  # quantile matrix should be exactly what we precomputed in method_quantiles_list
  for (i in seq_along(method_quantiles_list$pooled)) {
    expect_identical(scen1$pooled[[i]], method_quantiles_list$pooled[[i]])
  }
})


test_that("mapUniqueTrials: with previous trials, only GO trials are updated from hash tables", {
  foreach::registerDoSEQ()
  set.seed(123)
  
  # Start from a realistic scenario: 2 cohorts, 2 trials, with previous_analyses
  scen <- getScenario(
    n_subjects     = c(10, 10),
    response_rates = c(0.1, 0.2),
    n_trials       = 2
  )
  
  # We only care about the first column of go_decisions in mapUniqueTrials.
  # Make trial 1: GO (1), trial 2: NoGo (0).
  scen$previous_analyses$go_decisions <- cbind(
    overall    = c(1L, 0L),
    decision_1 = c(1L, 0L),  # unused but keeps typical structure
    decision_2 = c(1L, 0L)
  )
  
  # Old quantiles: one matrix per trial, 2 cohorts → columns p_1, p_2
  prev_post <- list(
    pooled = list(
      matrix(c("prev1_11", "prev1_12"), nrow = 1,
             dimnames = list("dummy", c("p_1", "p_2"))),
      matrix(c("prev2_11", "prev2_12"), nrow = 1,
             dimnames = list("dummy", c("p_1", "p_2")))
    )
  )
  scen$previous_analyses$post_quantiles <- prev_post
  
  scenario_list <- list(scenario_1 = scen)
  class(scenario_list) <- "scenario_list"
  
  # trials_unique_calc: (r, n) pairs for both trials
  trials_unique_calc <- cbind(scen$n_responders, scen$n_subjects)
  
  # New quantiles that the hash tables should give for each (r, n) row
  new_q1 <- matrix(c("new1_11", "new1_12"), nrow = 1,
                   dimnames = list("dummy", c("p_1", "p_2")))
  new_q2 <- matrix(c("new2_11", "new2_12"), nrow = 1,
                   dimnames = list("dummy", c("p_1", "p_2")))
  
  method_quantiles_list <- list(
    pooled = list(new_q1, new_q2)
  )
  
  out <- mapUniqueTrials(
    scenario_list              = scenario_list,
    method_quantiles_list      = method_quantiles_list,
    trials_unique_calc         = trials_unique_calc,
    applicable_previous_trials = TRUE
  )
  
  scen1_out <- out[["scenario_1"]]
  expect_true(is.list(scen1_out))
  expect_true("pooled" %in% names(scen1_out))
  
  # Trial 1 (GO) should be updated to new_q1 
  expect_identical(scen1_out$pooled[[1]], new_q1)
  
  # Trial 2 (NoGo) should retain its old quantiles prev2
  expect_identical(scen1_out$pooled[[2]], prev_post$pooled[[2]])
})
