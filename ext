getUniqueRowsNormal <- function(matrix) {
  n_rows <- nrow(matrix)
  n_cols <- ncol(matrix)

  unique_rows <- stats::aggregate(
    id ~ .,
    data = cbind(id = seq_len(n_rows), matrix),
    FUN  = length
  )

  unique_rows[, seq_len(n_cols)]
}

getUniqueTrialsNormal <- function(scenario_list) {

  all_scenarios_n_subjects <- do.call(
    rbind,
    lapply(scenario_list, function(x) x$n_subjects)
  )

  all_scenarios_overall_gos <- do.call(
    rbind,
    lapply(scenario_list, function(x) x$previous_analyses$go_decisions)
  )[, 1]

  getUniqueRowsNormal(
    cbind(
      all_scenarios_n_subjects,
      go_flag = all_scenarios_overall_gos
    )
  )
}

applicablePreviousTrialsNormal <- function(
  scenario_list,
  quantiles,
  n_cohorts,
  calc_differences
) {
  has_prev <- all(sapply(scenario_list, function(x) {
    !is.null(x$previous_analyses$post_quantiles)
  }))

  if (!has_prev) return(FALSE)

  ref_pq <- scenario_list[[1]]$previous_analyses$post_quantiles
  if (is.null(ref_pq$normal)) return(FALSE)

  ref_mat <- ref_pq$normal[[1]]

  same_structure <- all(sapply(seq_along(scenario_list), function(i) {
    pq <- scenario_list[[i]]$previous_analyses$post_quantiles
    if (is.null(pq$normal)) return(FALSE)
    mat <- pq$normal[[1]]
    identical(rownames(mat), rownames(ref_mat)) &&
      identical(colnames(mat), colnames(ref_mat))
  }))

  if (!same_structure) return(FALSE)

  needed_q_names <- paste0(quantiles * 100, "%")
  stored_q_names <- rownames(ref_mat)
  cond_q_subset  <- all(needed_q_names %in% stored_q_names)

  needed_cols <- paste0("mu_", seq_len(n_cohorts))
  cond_cols   <- all(needed_cols %in% colnames(ref_mat))

  if (!is.null(calc_differences)) {
    diff_names <- apply(calc_differences, 1, function(x) {
      paste0("mu_diff_", paste0(as.character(x), collapse = ""))
    })
    cond_diffs <- all(diff_names %in% colnames(ref_mat))
  } else {
    cond_diffs <- TRUE
  }

  has_prev && same_structure && cond_q_subset && cond_cols && cond_diffs
}

mapUniqueTrialsNormal <- function(
  scenario_list,
  method_quantiles_list,
  trials_unique_calc,
  applicable_previous_trials
) {
  method_names     <- names(method_quantiles_list)  # typically "normal"
  scenario_numbers <- sapply(scenario_list, function(x) x$scenario_number)

  hash_keys        <- getHashKeys(trials_unique_calc)
  hash_tables_list <- vector("list", length(method_quantiles_list))

  for (n in seq_along(hash_tables_list)) {
    hash_tables_list[[n]] <- createHashTable(hash_keys, method_quantiles_list[[n]])
  }

  exported_stuff <- c("convertVector2Matrix")
  "%do%" <- foreach::"%do%"

  scenario_method_quantiles_list <- foreach::foreach(
    k = seq_along(scenario_numbers),
    .verbose = FALSE,
    .export  = exported_stuff
  ) %do% {

    scenario_data_matrix <- scenario_list[[k]]$n_subjects

    if (applicable_previous_trials &&
        !is.null(scenario_list[[k]]$previous_analyses$post_quantiles)) {

      scenario_go_flags         <- scenario_list[[k]]$previous_analyses$go_decisions[, 1] > 0
      scenario_method_quantiles <- scenario_list[[k]]$previous_analyses$post_quantiles

    } else {

      scenario_go_flags         <- rep(TRUE, nrow(scenario_data_matrix))
      scenario_method_quantiles <- vector("list", length(method_names))
      names(scenario_method_quantiles) <- method_names

    }

    if (any(scenario_go_flags)) {

      scenario_data_matrix_go <- convertVector2Matrix(
        scenario_data_matrix[scenario_go_flags, , drop = FALSE]
      )
      search_keys <- getHashKeys(scenario_data_matrix_go)

      for (n in seq_along(method_names)) {
        scenario_method_quantiles[[method_names[n]]][scenario_go_flags] <-
          getHashValues(search_keys, hash_tables_list[[n]])
      }
    }

    scenario_method_quantiles
  }

  names(scenario_method_quantiles_list) <- paste0("scenario_", scenario_numbers)
  scenario_method_quantiles_list
}

