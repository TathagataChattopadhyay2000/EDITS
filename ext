#' @title continueRecruitment
#' @md
#' @description This function continues the recruitment of subjects for a set of scenarios
#' based on the Go / NoGo decisions in the simulated trial outcomes of said scenarios.
#' @param n_subjects_add_list A list that contains for each scenario an integer vector for
#' the number of subjects per cohort to be additionally recruited.
#' @param decisions_list A list with decisions per scenario created with
#' \code{\link[bhmbasket]{getGoDecisions}}
#' @param method_name A string for the method name of the analysis the decisions are based on.
#' Can be `NULL` if only one method has been used for analysis, Default: `NULL`
#' @return An object of class `scenario_list` with the scenario data for each specified scenario.
#' @details
#' This function is intended to be used for analyses with the following work flow:\cr
#' `simulateScenarios()` -> `performAnalyses()` -> `getGoDecisions()`-> \cr
#' `continueRecruitment()` -> `performAnalyses()` -> `getGoDecisions()`-> \cr
#' `continueRecruitment()` -> ...
#'
#' Note that `n_subjects_add_list` takes the additional number of subjects to be recruited,
#' not the overall number of subjects.
#' This way the work flow can be repeated as often as
#' required, which can be useful e.g. for interim analyses.
#' @examples
#' interim_scenarios <- simulateScenarios(
#'   n_subjects_list     = list(c(10, 20, 30)),
#'   response_rates_list = list(rep(0.9, 3)),
#'   n_trials            = 10)
#'
#' interim_analyses <- performAnalyses(
#'   scenario_list       = interim_scenarios,
#'   target_rates        = rep(0.5, 3),
#'   n_mcmc_iterations   = 100)
#'
#' interim_gos <- getGoDecisions(
#'   analyses_list       = interim_analyses,
#'   cohort_names        = c("p_1", "p_2", "p_3"),
#'   evidence_levels     = c(0.5, 0.8, 0.5),
#'   boundary_rules      = quote(c(x[1] > 0.8, x[2] > 0.6, x[3] > 0.7)))
#'
#' scenarios_list <- continueRecruitment(
#'   n_subjects_add_list = list(c(30, 20, 10)),
#'   decisions_list      = interim_gos,
#'   method_name         = "exnex_adj")
#' @seealso
#'  \code{\link[bhmbasket]{simulateScenarios}}
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getGoDecisions}}
#' @rdname continueRecruitment
#' @author Stephan Wojciekowski
#' @export
continueRecruitment <- function (
    
  n_subjects_add_list,
  decisions_list,
  
  method_name = NULL
  
) {
  
  error_method_name <- simpleError(paste(
    "Please provide a string naming an analysis method for the argument 'method_name'",
    "Must be one of 'berry', 'exnex', 'exnex_adj', 'pooled', 'stratified'"))
  
  checkmate::assert_true(!missing(n_subjects_add_list), .var.name = "n_subjects_add_list")
  
  checkmate::assert_true(!missing(decisions_list),      .var.name = "decisions_list")
  
  checkmate::assert_class(decisions_list, "decision_list", .var.name = "decisions_list")
  
  
  if (is.null(method_name)) {
    
    n_methods <- length(decisions_list$scenario_1$decisions_list)
    
    if (n_methods > 1) {
      
      stop (error_method_name)
      
    } else {
      
      method_name <- names(decisions_list$scenario_1$decisions_list)
      
    }
    
  } else {
    
    method_name <- tryCatch({
      
      match.arg(
        method_name,
        choices    = c('berry', 'exnex', 'exnex_adj', 'pooled', 'stratified'),
        several.ok = FALSE)
      
    }, error = function (e) e)
    
    if (inherits(method_name, "error"))          stop (error_method_name)
    
  }
  
  if (!is.list(n_subjects_add_list)) {
    
    n_subjects_add_list <- rep(list(n_subjects_add_list), length(decisions_list))
    
  }
  
  
  checkmate::assert_list(
    
    n_subjects_add_list, types = c("integer", "numeric"),
    
    len = length(decisions_list), any.missing = FALSE
    
  )
  
  checkmate::assert_true(
    
    all(vapply(n_subjects_add_list,
               checkmate::test_integerish,
               logical(1),
               lower = 0, any.missing = FALSE)
    )
  )
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###
  ## Note: also some checks hereafter
  
  ## get scenario numbers
  scenario_numbers <- as.numeric(sub("scenario_", "", names(decisions_list)))
  
  scenario_list <- vector(mode = "list", length = length(decisions_list))
  names(scenario_list) <- paste0("scenario_", scenario_numbers)
  for (s in seq_along(scenario_list)) {
    
    if (!(method_name %in%
          decisions_list[[s]]$analysis_data$analysis_parameters$method_names)) {
      
      stop (simpleError("Selected method_name not analyzed"))
      
    }
    
    ## get new data, i.e. get new responders and new number of subjects per trial
    
    n_subjects_add <- n_subjects_add_list[[s]]
    response_rates <- decisions_list[[s]]$scenario_data$response_rates
    cohort_names   <- sub("rr_", "", colnames(response_rates))
    
    if (any(response_rates > 0 & response_rates < 1)) {
      
      index_new <- which(response_rates > 0 & response_rates < 1)
      
    } else {
      
      stop (simpleError(paste0(
        "Only historical cohorts in scenario ",
        decisions_list[[s]]$scenario_data$scenario_number)))
      
    }
    
    response_rates_new <- response_rates[, index_new]
    cohort_names_new   <- cohort_names[index_new]
    
    
    checkmate::assert_true(
      length(n_subjects_add) == length(response_rates_new)
    )
    
    n_trials <- decisions_list[[s]]$scenario_data$n_trials
    
    add_scenario <- getScenario(
      n_subjects     = n_subjects_add,
      response_rates = response_rates_new,
      cohort_names   = cohort_names_new,
      n_trials       = n_trials)
    
    ## Combine with existing data
    
    ## get previous decisions
    go_decisions <- decisions_list[[s]]$decisions_list[[method_name]]
    previous_gos <- go_decisions
    
    if ("overall" %in% colnames(go_decisions)) {
      overall_gos  <- go_decisions[, which(colnames(go_decisions) == "overall")]
      go_decisions <- go_decisions[, -which(colnames(go_decisions) == "overall")]
    } else {
      overall_gos <- rep(TRUE, nrow(go_decisions))
    }
    if (!all(index_new %in% as.numeric(sub("decision_", "", colnames(go_decisions))))) {
      stop (simpleError(
        "There must be a decision for each recruiting cohort in the 'decisions_list'"))
    }
    
    ## pick only cohorts that need updating
    go_decisions <- go_decisions[overall_gos, index_new]
    
    ## additional subjects and responders, only those that have overall go
    n_responders_add <- add_scenario$n_responders[overall_gos, ] * go_decisions
    n_subjects_add   <- add_scenario$n_subjects[overall_gos, ] * go_decisions
    
    ## existing cohorts that need updating
    n_responders <- decisions_list[[s]]$scenario_data$n_responders
    n_subjects   <- decisions_list[[s]]$scenario_data$n_subjects
    
    ## combine, only for cohorts that have overall go and need updating
    n_responders[overall_gos, index_new] <- n_responders[overall_gos, index_new] + n_responders_add
    n_subjects[overall_gos, index_new]   <- n_subjects[overall_gos, index_new] + n_subjects_add
    
    ## Saving Scenario
    
    scenario_list[[s]] <- list(
      n_subjects        = n_subjects,
      n_responders      = n_responders,
      response_rates    = response_rates,
      previous_analyses = list(
        go_decisions   = previous_gos,
        post_quantiles = decisions_list[[s]]$analysis_data$quantiles_list),
      n_trials          = n_trials)
    
    scenario_list[[s]]$scenario_number <-
      decisions_list[[s]]$scenario_data$scenario_number
    
  }
  
  class(scenario_list) <- "scenario_list"
  
  return (scenario_list)
  
}
