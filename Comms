test_that("mapUniqueTrials: with previous trials, only GO trials are updated from hash tables", {
  foreach::registerDoSEQ()
  set.seed(456)

  ## 1) Build a one-scenario object with 2 trials, 2 cohorts, incl. previous_analyses
  scene <- getScenario(
    n_subjects     = c(10, 10),
    response_rates = c(0.1, 0.2),
    n_trials       = 2
  )

  trial_data <- list(scenario_1 = scene)
  class(trial_data) <- "scenario_list"
  if (is.null(trial_data$scenario_1$scenario_number)) {
    trial_data$scenario_1$scenario_number <- 1L
  }

  ## 2) Force GO / NoGo pattern in the "overall" column:
  ##    - trial 1: GO
  ##    - trial 2: NoGo
  go_mat <- trial_data$scenario_1$previous_analyses$go_decisions
  go_mat[, 1] <- c(TRUE, FALSE)   # column 1 is used by mapUniqueTrials
  trial_data$scenario_1$previous_analyses$go_decisions <- go_mat

  ## 3) Create REAL "previous" post_quantiles using package functions
  n_trials   <- trial_data$scenario_1$n_trials
  n_cohorts  <- ncol(trial_data$scenario_1$n_subjects)
  quantiles  <- c(0.025, 0.5, 0.975)

  prior_parameters_list <- getPriorParameters(
    method_names = "berry",
    target_rates = rep(0.5, n_cohorts)
  )

  prep <- prepareAnalysis(
    method_name      = "berry",
    prior_parameters = prior_parameters_list[["berry"]],
    target_rates     = rep(0.5, n_cohorts)
  )

  ## Build a per-trial list of matrices (the structure mapUniqueTrials expects)
  old_q_list <- vector("list", length = n_trials)
  for (i in seq_len(n_trials)) {
    n_subj_i <- trial_data$scenario_1$n_subjects[i, , drop = FALSE]
    n_resp_i <- trial_data$scenario_1$n_responders[i, , drop = FALSE]

    old_q_list[[i]] <- getPostQuantiles(
      method_name       = "berry",
      quantiles         = quantiles,
      scenario_data     = list(
        n_subjects   = n_subj_i,
        n_responders = n_resp_i
      ),
      calc_differences  = NULL,
      j_parameters      = prep$j_parameters,
      j_model_file      = prep$j_model_file,
      j_data            = prep$j_data,
      n_mcmc_iterations = 100,
      save_path         = NULL,
      save_trial        = NULL
    )[[1]]
  }

  trial_data$scenario_1$previous_analyses$post_quantiles <- list(
    berry = old_q_list
  )

  ## 4) Build trials_unique and the subset used for new calculations
  trials_unique <- getUniqueTrials(trial_data)
  n_cohorts_u   <- (ncol(trials_unique) - 1L) / 2L

  ## applicable_previous_trials is TRUE by design in this test
  applicable_previous_trials <- TRUE

  ## We only (re)analyse unique GO trials:
  calc_trial_indices <- trials_unique[, ncol(trials_unique)] > 0
  trials_unique_calc <- trials_unique[calc_trial_indices, -ncol(trials_unique), drop = FALSE]

  ## 5) Create NEW quantiles for the GO pattern by modifying the existing ones
  ##    - trials_unique_calc contains only the GO pattern(s). Here, with our setup,
  ##      that's just trial 1.
  ##    - We derive a new matrix from the previous one to ensure they differ.
  new_q_go <- old_q_list[[1]] + 1  # simple shift to guarantee a difference

  method_quantiles_list <- list(
    berry = list(new_q_go)  # one entry per UNIQUE GO pattern
  )

  ## 6) Run mapUniqueTrials: should update only the GO trial
  out <- mapUniqueTrials(
    scenario_list              = trial_data,
    method_quantiles_list      = method_quantiles_list,
    trials_unique_calc         = trials_unique_calc,
    applicable_previous_trials = applicable_previous_trials
  )

  ## 7) Checks
  expect_type(out, "list")
  expect_identical(names(out), "scenario_1")

  scen1 <- out[["scenario_1"]]
  expect_true(is.list(scen1))
  expect_true("berry" %in% names(scen1))

  ## Trial 1 (GO) must now be the NEW quantiles
  expect_identical(scen1$berry[[1]], new_q_go)

  ## Trial 2 (NoGo) must remain with its original (old) quantiles
  expect_identical(scen1$berry[[2]], old_q_list[[2]])
})
