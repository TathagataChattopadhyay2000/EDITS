## 1) applicablePreviousTrialsNormal ---------------------------------

applicablePreviousTrialsNormal <- function(
  scenario_list,
  method_names,
  quantiles,
  n_cohorts,
  calc_differences
) {
  applicablePreviousTrials(
    scenario_list    = scenario_list,
    method_names     = method_names,
    quantiles        = quantiles,
    n_cohorts        = n_cohorts,
    calc_differences = calc_differences
  )
}

## 2) calcDiffsMCMCNormal --------------------------------------------

calcDiffsMCMCNormal <- function(posterior_samples, calc_differences) {
  calcDiffsMCMC(posterior_samples = posterior_samples,
                calc_differences  = calc_differences)
}

## 3) getModelFileNormal ---------------------------------------------

getModelFileNormal <- function() {
  system.file(
    package  = "bhmbasket",
    "jags_models",
    "bhm_normal.txt",
    mustWork = TRUE
  )
}

## 4) getPosteriorsNormal -------------------------------------------

getPosteriorsNormal <- function(
  j_parameters,
  j_model_file,
  j_data,
  n_mcmc_iterations
) {
  getPosteriors(
    j_parameters      = j_parameters,
    j_model_file      = j_model_file,
    j_data            = j_data,
    n_mcmc_iterations = n_mcmc_iterations
  )
}

## 5) getPostQuantilesNormal ----------------------------------------

getPostQuantilesNormal <- function(
  method_name,
  quantiles,
  scenario_data,
  calc_differences = NULL,
  j_parameters,
  j_model_file,
  j_data,
  n_mcmc_iterations = 1e4,
  save_path         = NULL,
  save_trial        = NULL
) {
  if (!identical(method_name, "bhm_normal")) {
    stop("getPostQuantilesNormal currently only supports method_name = 'bhm_normal'")
  }

  trials   <- scenario_data$trials
  n_trials <- length(trials)

  if (is.null(save_trial) && !is.null(save_path)) {
    save_trial <- sample(seq_len(n_trials), size = 1)
  }

  out <- vector("list", n_trials)

  for (t in seq_len(n_trials)) {
    y_list <- trials[[t]]$y_list
    out[[t]] <- getPostQuantilesOfTrialNormal(
      y_list           = y_list,
      j_data           = j_data,
      j_parameters     = j_parameters,
      j_model_file     = j_model_file,
      method_name      = method_name,
      quantiles        = quantiles,
      calc_differences = calc_differences,
      n_mcmc_iterations = n_mcmc_iterations,
      save_path        = save_path,
      save_trial       = if (!is.null(save_trial) && t == save_trial) t else NULL
    )
  }

  out
}

## 6) getPostQuantilesOfTrialNormal ---------------------------------

getPostQuantilesOfTrialNormal <- function(
  y_list,
  j_data,
  j_parameters,
  j_model_file,
  method_name,
  quantiles,
  calc_differences,
  n_mcmc_iterations,
  save_path,
  save_trial
) {
  K <- length(y_list)
  if (K < 1L) stop("y_list must be a non-empty list of numeric vectors.")

  n_vec <- vapply(y_list, length, integer(1L))
  if (any(n_vec <= 0L)) stop("All cohorts in y_list must have at least one observation.")

  max_n <- max(n_vec)
  y_mat <- matrix(NA_real_, nrow = K, ncol = max_n)
  for (k in seq_len(K)) {
    y_mat[k, seq_len(n_vec[k])] <- y_list[[k]]
  }

  j_data_full <- c(
    j_data,
    list(
      K = K,
      n = n_vec,
      y = y_mat
    )
  )

  posterior_samples <- getPosteriorsNormal(
    j_parameters      = j_parameters,
    j_model_file      = j_model_file,
    j_data            = j_data_full,
    n_mcmc_iterations = n_mcmc_iterations
  )

  mu_cols <- grepl("^mu_", colnames(posterior_samples))
  mu_post <- posterior_samples[, mu_cols, drop = FALSE]

  if (ncol(mu_post) != K) {
    stop("Could not identify exactly K mu columns in posterior_samples.")
  }

  colnames(mu_post) <- paste0("p_", seq_len(K))

  if (!is.null(calc_differences)) {
    calc_differences <- convertVector2Matrix(calc_differences)
    mu_post <- calcDiffsMCMCNormal(
      posterior_samples = mu_post,
      calc_differences  = calc_differences
    )
  }

  if (!is.null(save_path) && !is.null(save_trial)) {
    saveRDS(
      posterior_samples,
      file = file.path(
        save_path,
        paste0("posterior_samples_", save_trial, "_", method_name, "_rds")
      )
    )
  }

  posterior2quantilesNormal(
    quantiles  = quantiles,
    posteriors = mu_post
  )
}

## 7) getPostQuantilesPooledNormal ----------------------------------

getPostQuantilesPooledNormal <- function(
  j_data,
  quantiles,
  calc_differences
) {
  stop("getPostQuantilesPooledNormal is not implemented for normal endpoints. Use bhm_normal instead.")
}

## 8) getPostQuantilesStratifiedNormal ------------------------------

getPostQuantilesStratifiedNormal <- function(
  j_data,
  quantiles,
  calc_differences,
  n_mcmc_iterations
) {
  stop("getPostQuantilesStratifiedNormal is not implemented for normal endpoints. Use bhm_normal instead.")
}

## 9) getUniqueRowsNormal -------------------------------------------

getUniqueRowsNormal <- function(mat) {
  getUniqueRows(mat)
}

## 10) getUniqueTrialsNormal ----------------------------------------

getUniqueTrialsNormal <- function(scenario_list_normal) {
  stop("getUniqueTrialsNormal not implemented for normal endpoints (continuous data rarely duplicates exactly).")
}

## 11) loadAnalysesNormal -------------------------------------------

loadAnalysesNormal <- function(
  scenario_numbers,
  analysis_numbers = rep(1, length(scenario_numbers)),
  load_path        = tempdir()
) {
  loadAnalyses(
    scenario_numbers = scenario_numbers,
    analysis_numbers = analysis_numbers,
    load_path        = load_path
  )
}

## 12) performAnalysesNormal ----------------------------------------

performAnalysesNormal <- function(
  scenario_list,
  evidence_levels   = c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975),
  calc_differences  = NULL,
  n_mcmc_iterations = 1e4,
  seed              = 1,
  verbose           = TRUE
) {
  error_scenario_list <- simpleError(
    "Please provide a list of scenarios for 'scenario_list'. Each scenario must contain a 'trials' element with 'y_list' per trial."
  )
  error_evidence_levels <- simpleError(
    "Please provide a vector of numerics in (0, 1) for 'evidence_levels'."
  )
  error_n_mcmc_iterations <- simpleError(
    "Please provide a single positive integer for 'n_mcmc_iterations'."
  )
  error_verbose <- simpleError(
    "Please provide a logical for 'verbose'."
  )

  if (missing(scenario_list) || !is.list(scenario_list) || length(scenario_list) == 0L) {
    stop(error_scenario_list)
  }

  first_scen <- scenario_list[[1L]]
  if (is.null(first_scen$trials) || length(first_scen$trials) == 0L) {
    stop(error_scenario_list)
  }
  if (is.null(first_scen$trials[[1L]]$y_list)) {
    stop(error_scenario_list)
  }

  if (missing(evidence_levels) ||
      !is.numeric.in.zero.one(evidence_levels)) stop(error_evidence_levels)

  if (missing(n_mcmc_iterations) ||
      !is.single.positive.wholenumber(n_mcmc_iterations)) stop(error_n_mcmc_iterations)

  if (!is.logical(verbose) || length(verbose) != 1L) stop(error_verbose)

  set.seed(seed)

  quantiles <- sort(unique(round(
    1 - c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975, evidence_levels),
    9
  )))

  K <- length(first_scen$trials[[1L]]$y_list)

  if (!is.null(calc_differences)) {
    calc_differences <- convertVector2Matrix(calc_differences)
    if (!is.positive.wholenumber(calc_differences)) {
      stop("All entries in 'calc_differences' must be positive integers.")
    }
    if (ncol(calc_differences) != 2L) {
      stop("calc_differences must have exactly 2 columns.")
    }
    if (max(calc_differences) > K) {
      stop("Values in 'calc_differences' must not exceed the number of cohorts.")
    }
  }

  j_model_file <- getModelFileNormal()
  j_parameters <- c("mu", "mu_pop", "prec_tau", "prec_sigma")
  j_data_fixed <- list()

  n_scenarios   <- length(scenario_list)
  analyses_list <- vector("list", n_scenarios)
  names(analyses_list) <- names(scenario_list)

  if (verbose) {
    message(format(Sys.time(), "%d-%h-%Y"), " Performing Analyses (normal endpoint)")
  }

  for (s in seq_along(scenario_list)) {

    scen   <- scenario_list[[s]]
    trials <- scen$trials
    n_tr   <- length(trials)

    if (verbose) {
      message("   Scenario ", s, " (", n_tr, " trial", ifelse(n_tr == 1L, "", "s"), ")")
    }

    method_name    <- "bhm_normal"
    quantiles_list <- list()
    quantiles_list[[method_name]] <- vector("list", n_tr)

    for (t in seq_len(n_tr)) {

      if (verbose) {
        message("      Trial ", t, " / ", n_tr)
      }

      q_mat <- getPostQuantilesOfTrialNormal(
        y_list           = trials[[t]]$y_list,
        j_data           = j_data_fixed,
        j_parameters     = j_parameters,
        j_model_file     = j_model_file,
        method_name      = method_name,
        quantiles        = quantiles,
        calc_differences = calc_differences,
        n_mcmc_iterations = n_mcmc_iterations,
        save_path        = NULL,
        save_trial       = NULL
      )

      quantiles_list[[method_name]][[t]] <- q_mat
    }

    scenario_number <- if (!is.null(scen$scenario_number)) scen$scenario_number else s

    scenario_data <- scen
    scenario_data$endpoint        <- "normal"
    scenario_data$scenario_number <- scenario_number

    analysis_parameters <- list(
      quantiles          = quantiles,
      method_names       = method_name,
      n_mcmc_iterations  = n_mcmc_iterations,
      seed               = seed,
      calc_differences   = calc_differences
    )

    analyses_list[[s]] <- list(
      quantiles_list      = quantiles_list,
      scenario_data       = scenario_data,
      analysis_parameters = analysis_parameters
    )

    names(analyses_list)[s] <- paste0("scenario_", scenario_number)
  }

  class(analyses_list) <- c("analysis_listnormal", "analysis_list")
  analyses_list
}

## 13) posterior2quantilesNormal ------------------------------------

posterior2quantilesNormal <- function(quantiles, posteriors) {
  posteriors2Quantiles(
    quantiles  = quantiles,
    posteriors = posteriors
  )
}

## 14) prepareAnalysisnormal ----------------------------------------

prepareAnalysisnormal <- function(
  method_name     = "bhm_normal",
  prior_parameters = NULL,
  target_rates     = NULL
) {
  if (!identical(method_name, "bhm_normal")) {
    stop("prepareAnalysisnormal only supports method_name = 'bhm_normal'")
  }

  j_model_file <- getModelFileNormal()
  j_parameters <- c("mu", "mu_pop", "prec_tau", "prec_sigma")
  j_data       <- list()

  list(
    j_parameters = j_parameters,
    j_model_file = j_model_file,
    j_data       = j_data
  )
}

## 15) print.analysis_listnormal ------------------------------------

print.analysis_listnormal <- function(x, digits = 2, ...) {
  print.analysis_list(x, digits = digits, ...)
}

## 15b) qbetaDiffNormal ---------------------------------------------

qbetaDiffNormal <- function(
  quantiles,
  x_1_shape1,
  x_1_shape2,
  x_2_shape1,
  x_2_shape2,
  n_mcmc = 1e6
) {
  qbetaDiff(
    quantiles  = quantiles,
    x_1_shape1 = x_1_shape1,
    x_1_shape2 = x_1_shape2,
    x_2_shape1 = x_2_shape1,
    x_2_shape2 = x_2_shape2,
    n_mcmc     = n_mcmc
  )
}

## 16) saveAnalysesNormal -------------------------------------------

saveAnalysesNormal <- function(
  analyses_list,
  save_path        = tempdir(),
  analysis_numbers = NULL
) {
  saveAnalyses(
    analyses_list    = analyses_list,
    save_path        = save_path,
    analysis_numbers = analysis_numbers
  )
}
