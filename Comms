'ORIGINAL-----

## exnex ####

getPriorParametersExNex <- function (

  target_rates,
  tau_scale = 1,
  n_worth   = 1,

  w_j       = 0.5

) {

  error_target_rates <- simpleError(
    "Please provide a vector of numerics in (0, 1) for the argument 'target_rates'")
  error_tau_scale    <- simpleError(
    "Please provide a positive numeric for the argument 'tau_scale'")
  error_n_worth      <- simpleError(
    "Please provide a positive integer for the argument 'n_worth'")
  error_w_j          <- simpleError(
    "Please provide a numeric in (0, 1) for the argument 'w_j'")

  if (missing(target_rates)) stop (error_target_rates)

  if (!is.numeric.in.zero.one(target_rates))    stop (error_target_rates)
  if (!is.single.positive.numeric(tau_scale))   stop (error_tau_scale)
  if (!is.single.positive.wholenumber(n_worth)) stop (error_n_worth)
  if (!is.single.numeric(w_j) ||
      any(w_j < 0) ||
      any(w_j > 1))                             stop (error_w_j)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  target_rate_max_var <- target_rates[abs(target_rates - 0.5) == max(abs(target_rates - 0.5))][1]

  mu_var <- getMuVar(target_rate_max_var, tau_scale, n_worth)

  if (mu_var <= 0) stop(simpleError(paste(
    "The provided input parameters lead to a variance of mu <= 0.",
    "Consider to decrease 'tau_scale' or 'n_worth'")))

  prior_parameters <- list(
    mu_mean   = logit(target_rate_max_var),
    mu_sd     = mu_var^0.5,
    tau_scale = tau_scale,

    mu_j  = logit(target_rates),
    tau_j = getMuVar(target_rates, 0, n_worth)^0.5,

    w_j   = w_j)

  prior_parameters_list <- list (exnex = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersExNex
#' @md
#' @description This function sets prior parameters for the analysis method `"exnex"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param mu_mean A numeric for the mean of \eqn{\mu}
#' @param mu_sd A positive numeric for the standard deviation of \eqn{\mu}
#' @param tau_scale A positive numeric for the scale parameter of \eqn{\tau}
#' @param mu_j A vector of numerics for the means \eqn{\mu_j}
#' @param tau_j A vector of positive numerics for the standard deviations \eqn{\tau_j}
#' @param w_j A numeric in `(0, 1)` for the weight of the Ex component
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' This function sets the prior parameters for the method proposed by Neuenschwander et al. (2016).
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_exnex <- setPriorParametersExNex(0, 1, 2, c(4, 5), c(6, 7), 0.8)
#' @rdname setPriorParametersExNex
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @references Neuenschwander, Beat, et al. "Robust exchangeability designs
#' for early phase clinical trials with multiple strata."
#' \emph{Pharmaceutical statistics} 15.2 (2016): 123-134.
#' @export
setPriorParametersExNex <- function (

  mu_mean,
  mu_sd,
  tau_scale,

  mu_j,
  tau_j,

  w_j

) {

  error_mu_mean   <- simpleError("Please provide a numeric for the argument 'mu_mean'")
  error_mu_sd     <- simpleError("Please provide a positive numeric for the argument 'mu_sd'")
  error_tau_scale <- simpleError("Please provide a positive numeric for the argument 'tau_scale'")
  error_mu_j      <- simpleError("Please provide a (vector of) numeric(s) for the argument 'mu_j'")
  error_tau_j     <- simpleError(
    "Please provide a (vector of) positive numeric(s) for the argument 'tau_j'")
  error_w_j   <- simpleError("Please provide a numeric in (0, 1) for the argument 'w_j'")

  if (missing(mu_mean))   stop (error_mu_mean)
  if (missing(mu_sd))     stop (error_mu_sd)
  if (missing(tau_scale)) stop (error_tau_scale)
  if (missing(mu_j))      stop (error_mu_j)
  if (missing(tau_j))     stop (error_tau_j)
  if (missing(w_j))       stop (error_w_j)

  if (!is.numeric(mu_mean))                   stop (error_mu_mean)
  if (!is.positive.numeric(mu_sd))            stop (error_mu_sd)
  if (!is.single.positive.numeric(tau_scale)) stop (error_tau_scale)
  if (!is.numeric(mu_j))                      stop (error_mu_j)
  if (!is.positive.numeric(tau_j))            stop (error_tau_j)
  if (!is.numeric(w_j) ||
      !all(w_j >= 0) ||
      !all(w_j <= 1))                         stop (error_w_j)

  if (!identical(length(mu_mean), length(mu_sd))) stop (simpleError(
    "'mu_mean' and 'mu_sd' must have save length"))

  if (!identical(length(mu_mean), 1L)) {
    if (!identical(length(w_j), length(mu_mean) + 1L)) stop (simpleError(
      "'w_j' must have length equal to length(mu_mean) + 1 if length(mu_mean) > 1"))
  }

  if (!identical(length(w_j), 1L)) {
    if (!identical(length(w_j), length(mu_mean) + 1L)) stop (simpleError(
      "'w_j' must have length 1 or 2, if length(mu_mean) = 1"))
    if (!isTRUE(all.equal(sum(w_j), 1))) stop (simpleError(
      "Sum over items in 'w_j' must equal 1 if length(w_j) > 1"))
  }

  if (!identical(length(mu_j), length(tau_j)))
    stop (simpleError("mu_j and tau_j must have the same length"))

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <-  list(mu_mean   = mu_mean,
                            mu_sd     = mu_sd,
                            tau_scale = tau_scale,
                            mu_j      = mu_j,
                            tau_j     = tau_j,
                            w_j       = w_j)

  prior_parameters_list <- list (exnex = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

## exnex_adj ####

getPriorParametersExNexAdj <- function (

  target_rates,
  tau_scale = 1,
  n_worth   = 1,

  w_j       = 0.5

) {

  error_target_rates <- simpleError(
    paste("Please provide a vector of numerics in (0, 1) for the argument 'target_rates'"))
  error_tau_scale    <- simpleError("Please provide a positive numeric for the argument 'tau_scale'")
  error_n_worth      <- simpleError("Please provide a positive integer for the argument 'n_worth'")
  error_w_j          <- simpleError("Please provide a numeric in (0, 1) for the argument 'w_j'")

  if (missing(target_rates)) stop (error_target_rates)

  if (!is.numeric.in.zero.one(target_rates))    stop (error_target_rates)
  if (!is.single.positive.numeric(tau_scale))   stop (error_tau_scale)
  if (!is.single.positive.wholenumber(n_worth)) stop (error_n_worth)
  if (!is.single.numeric(w_j) ||
      any(w_j < 0) ||
      any(w_j > 1))                             stop (error_w_j)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- getPriorParametersExNex(target_rates, tau_scale, n_worth, w_j)[[1]]

  prior_parameters$mu_mean <- 0
  prior_parameters$mu_j    <- rep(0, length(target_rates))

  prior_parameters_list <- list (exnex_adj = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersExNexAdj
#' @md
#' @description This function sets prior parameters for the analysis method `"exnex_adj"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param mu_mean A numeric for the mean of \eqn{\mu}
#' @param mu_sd A positive numeric for the standard deviation of \eqn{\mu}
#' @param tau_scale A positive numeric for the scale parameter of \eqn{\tau}
#' @param mu_j A vector of numerics for the means \eqn{\mu_j}
#' @param tau_j A vector of positive numerics for the standard deviations \eqn{\tau_j}
#' @param w_j A numeric in `(0, 1)` for the weight of the Ex component
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' This function sets the prior parameters for the method ExNex Adjusted, which combines
#' the approach proposed by Neuenschwander et al. (2016) and the approach proposed by
#' Berry et al. (2013).
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_exnex_adj <- setPriorParametersExNexAdj(0, 1, 2, c(4, 5), c(6, 7), 0.8)
#' @rdname setPriorParametersExNexAdj
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersExNexAdj <- function (

  mu_mean,
  mu_sd,
  tau_scale,

  mu_j,
  tau_j,

  w_j

) {

  error_mu_mean   <- simpleError("Please provide a numeric for the argument 'mu_mean'")
  error_mu_sd     <- simpleError("Please provide a positive numeric for the argument 'mu_sd'")
  error_tau_scale <- simpleError("Please provide a positive numeric for the argument 'tau_scale'")
  error_mu_j      <- simpleError("Please provide a (vector of) numeric(s) for the argument 'mu_j'")
  error_tau_j     <- simpleError(
    "Please provide a (vector of) positive numeric(s) for the argument 'tau_j'")
  error_w_j   <- simpleError("Please provide a numeric in (0, 1) for the argument 'w_j'")

  if (missing(mu_mean))   stop (error_mu_mean)
  if (missing(mu_sd))     stop (error_mu_sd)
  if (missing(tau_scale)) stop (error_tau_scale)
  if (missing(mu_j))      stop (error_mu_j)
  if (missing(tau_j))     stop (error_tau_j)
  if (missing(w_j))       stop (error_w_j)

  if (!is.numeric(mu_mean))                    stop (error_mu_mean)
  if (!is.positive.numeric(mu_sd))             stop (error_mu_sd)
  if (!is.single.positive.numeric(tau_scale))  stop (error_tau_scale)
  if (!is.numeric(mu_j))                       stop (error_mu_j)
  if (!is.positive.numeric(tau_j))             stop (error_tau_j)
  if (!is.single.numeric(w_j) ||
      any(w_j < 0) ||
      any(w_j > 1))                             stop (error_w_j)

  if (!identical(length(mu_mean), length(mu_sd))) stop (simpleError(
    "'mu_mean' and 'mu_sd' must have save length"))

  if (!identical(length(mu_mean), 1L)) {
    if (!identical(length(w_j), length(mu_mean) + 1L)) stop (simpleError(
      "'w_j' must have length equal to length(mu_mean) + 1 if length(mu_mean) > 1"))
  }

  if (!identical(length(w_j), 1L)) {
    if (!identical(length(w_j), length(mu_mean) + 1L)) stop (simpleError(
      "'w_j' must have length 1 or 2, if length(mu_mean) = 1"))
  }

  if (!identical(length(mu_j), length(tau_j)))
    stop (simpleError("mu_j and tau_j must have the same length"))

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters_list <- setPriorParametersExNex(mu_mean, mu_sd, tau_scale, mu_j, tau_j, w_j)
  names(prior_parameters_list) <- "exnex_adj"

  return (prior_parameters_list)

}

## pooled ####

getPriorParametersPooled <- function (

  target_rates,
  n_worth = 1

) {

  error_target_rates <- simpleError(
    "Please provide a vector of numerics in (0, 1) for the argument 'target_rates'")
  error_n_worth      <- simpleError(
    "Please provide a positive integer for the argument 'n_worth'")

  if (missing(target_rates)) stop (error_target_rates)

  if (!is.numeric.in.zero.one(target_rates))    stop (error_target_rates)
  if (!is.single.positive.wholenumber(n_worth)) stop (error_n_worth)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  target_rate_min_var <- target_rates[abs(target_rates - 0.5) == min(abs(target_rates - 0.5))][1]

  a <- target_rate_min_var * n_worth
  b <- (1 - target_rate_min_var) * n_worth

  prior_parameters <- list(a = a, b = b)

  prior_parameters_list        <- list(pooled = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersPooled
#' @md
#' @description This function sets prior parameters for the analysis method `"pooled"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param a A positive numeric for \eqn{\alpha}
#' @param b A positive numeric for \eqn{\beta}
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' The method `"pooled"` is a beta-binomial model that pools all cohorts.
#' The prior parameters are the scale parameters of the beta prior distribution.
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_pooled <- setPriorParametersPooled(1, 2)
#' @rdname setPriorParametersPooled
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersPooled <- function (

  a,
  b

) {

  error_a <- simpleError(
    "Please provide a positive numeric for the argument 'a'")
  error_b <- simpleError(
    "Please provide a positive numeric for the argument 'b'")

  if (missing(a)) stop (error_a)
  if (missing(b)) stop (error_b)

  if (!is.single.positive.numeric(a)) stop (error_a)
  if (!is.single.positive.numeric(b)) stop (error_b)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- list(a = a, b = b)

  prior_parameters_list        <- list(pooled = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

## stratified ####

getPriorParametersStratified <- function (

  target_rates,
  n_worth = 1

) {

  error_target_rates <- simpleError(
    "Please provide a vector of numerics in (0, 1) for the argument 'target_rates'")
  error_n_worth      <- simpleError(
    "Please provide a positive integer for the argument 'n_worth'")

  if (missing(target_rates)) stop (error_target_rates)

  if (!is.numeric.in.zero.one(target_rates))    stop (error_target_rates)
  if (!is.single.positive.wholenumber(n_worth)) stop (error_n_worth)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  a_j <- target_rates * n_worth
  b_j <- (1 - target_rates) * n_worth

  prior_parameters <- list(a_j = a_j, b_j = b_j)

  prior_parameters_list        <- list(stratified = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersStratified
#' @md
#' @description This function sets prior parameters for the analysis method `"stratified"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param a_j A vector of positive numerics for \eqn{\alpha}
#' @param b_j A vector of positive numerics for \eqn{\beta}
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' The method `"stratified"` is a beta-binomial model that assesses each cohort individually.
#' The prior parameters are the scale parameters of the beta prior distributions.
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_pooled <- setPriorParametersStratified(c(1, 2), c(3, 4))
#' @rdname setPriorParametersStratified
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersStratified <- function (

  a_j,
  b_j

) {

  error_a_j <- simpleError(
    "Please provide a (vector of) positive numeric(s) in for the argument 'a_j'")
  error_b_j <- simpleError(
    "Please provide a (vector of) positive numeric(s) in for the argument 'b_j'")

  if (missing(a_j)) stop (error_a_j)
  if (missing(b_j)) stop (error_b_j)

  if (!is.positive.numeric(a_j)) stop (error_a_j)
  if (!is.positive.numeric(b_j)) stop (error_b_j)

  if (!identical(length(a_j), length(b_j)))
    stop (simpleError("a_j and b_j must have the same length"))

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- list(a_j = a_j, b_j = b_j)

  prior_parameters_list        <- list(stratified = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}


'TO BE MODIIFED-------------

## exnex ####

getPriorParametersExNex <- function (

  target_rates,
  tau_scale = 1,
  n_worth   = 1,

  w_j       = 0.5

) {
  
  error_target_rates <- 
    "Providing a vector of numerics in (0, 1) for the argument 'target_rates'"
  error_tau_scale    <- 
    "Providing a positive numeric for the argument 'tau_scale'"
  error_n_worth      <- 
    "Providing a positive integer for the argument 'n_worth'"
  error_w_j          <- 
    "Providing a numeric in (0, 1) for the argument 'w_j'"
  
  checkmate::assertNumeric(target_rates, any.missing = FALSE, .var.name = error_target_rates)
  checkmate::assertTRUE(all(target_rates > 0 & target_rates < 1), .var.name = error_target_rates)
  
  checkmate::assertNumber(tau_scale, .var.name = error_tau_scale)
  checkmate::assertTRUE(tau_scale > 0, .var.name = error_tau_scale)
  
  checkmate::assertInt(n_worth, lower = 1, .var.name = error_n_worth)
  
  checkmate::assertNumeric(w_j, lower = 0, upper = 1, len = 1, .var.name = error_w_j)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  target_rate_max_var <- target_rates[abs(target_rates - 0.5) == max(abs(target_rates - 0.5))][1]

  mu_var <- getMuVar(target_rate_max_var, tau_scale, n_worth)

  if (mu_var <= 0) stop(simpleError(paste(
    "The provided input parameters lead to a variance of mu <= 0.",
    "Consider to decrease 'tau_scale' or 'n_worth'")))

  prior_parameters <- list(
    mu_mean   = logit(target_rate_max_var),
    mu_sd     = mu_var^0.5,
    tau_scale = tau_scale,

    mu_j  = logit(target_rates),
    tau_j = getMuVar(target_rates, 0, n_worth)^0.5,

    w_j   = w_j)

  prior_parameters_list <- list (exnex = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersExNex
#' @md
#' @description This function sets prior parameters for the analysis method `"exnex"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param mu_mean A numeric for the mean of \eqn{\mu}
#' @param mu_sd A positive numeric for the standard deviation of \eqn{\mu}
#' @param tau_scale A positive numeric for the scale parameter of \eqn{\tau}
#' @param mu_j A vector of numerics for the means \eqn{\mu_j}
#' @param tau_j A vector of positive numerics for the standard deviations \eqn{\tau_j}
#' @param w_j A numeric in `(0, 1)` for the weight of the Ex component
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' This function sets the prior parameters for the method proposed by Neuenschwander et al. (2016).
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_exnex <- setPriorParametersExNex(0, 1, 2, c(4, 5), c(6, 7), 0.8)
#' @rdname setPriorParametersExNex
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @references Neuenschwander, Beat, et al. "Robust exchangeability designs
#' for early phase clinical trials with multiple strata."
#' \emph{Pharmaceutical statistics} 15.2 (2016): 123-134.
#' @export
setPriorParametersExNex <- function (

  mu_mean,
  mu_sd,
  tau_scale,

  mu_j,
  tau_j,

  w_j

) {

  checkmate::assert_numeric(mu_mean, any.missing = FALSE, .var.name = "mu_mean")

  checkmate::assert_numeric(mu_sd, lower = 0, any.missing = FALSE, .var.name = "mu_sd")
  checkmate::assertTRUE(all(mu_sd > 0), .var.name = "mu_sd")
  
  checkmate::assertNumber(tau_scale, .var.name = "tau_scale")
  checkmate::assertTRUE(tau_scale > 0, .var.name = "tau_scale")
  
  checkmate::assert_numeric(mu_j, any.missing = FALSE, .var.name = "mu_j")
  
  checkmate::assert_numeric(tau_j, any.missing = FALSE, .var.name = "tau_j")
  checkmate::assertTRUE(all(tau_j > 0), .var.name = "tau_j")

  checkmate::assert_numeric(w_j, lower = 0, upper = 1, any.missing = FALSE, .var.name = "w_j")
  
  checkmate::assert_true(length(mu_mean) == length(mu_sd), .var.name = "'mu_mean' and 'mu_sd' must have same length")
  
  checkmate::assert_true(length(mu_j) == length(tau_j), .var.name = "'mu_j' and 'tau_j' must have same length")
  
  if (length(mu_mean) > 1) {
    checkmate::assert_true(length(w_j) == length(mu_mean) + 1, .var.name =
                "'w_j' must have length equal to length(mu_mean) + 1 if length(mu_mean) > 1")
  } else {
    checkmate::assert_true(length(w_j) %in% c(1, 2), .var.name =
                "'w_j' must have length 1 or 2 if length(mu_mean) = 1")
  }
  
  if (length(w_j) > 1) {
    checkmate::assert_true(isTRUE(all.equal(sum(w_j), 1)), .var.name =
                "Sum over items in 'w_j' must equal 1 if length(w_j) > 1")
  }
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <-  list(mu_mean   = mu_mean,
                            mu_sd     = mu_sd,
                            tau_scale = tau_scale,
                            mu_j      = mu_j,
                            tau_j     = tau_j,
                            w_j       = w_j)

  prior_parameters_list <- list (exnex = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

## exnex_adj ####

getPriorParametersExNexAdj <- function (

  target_rates,
  tau_scale = 1,
  n_worth   = 1,

  w_j       = 0.5

) {
  
  checkmate::assertNumeric(target_rates, any.missing = FALSE, .var.name = "target_rates")
  checkmate::assertTRUE(all(target_rates > 0 & target_rates < 1), .var.name = "target_rates")
  
  checkmate::assertNumber(tau_scale, .var.name = "tau_scale")
  checkmate::assertTRUE(tau_scale > 0, .var.name = "tau_scale")
  
  checkmate::assertInt(n_worth, lower = 1, .var.name = "n_worth")
  
  checkmate::assertNumeric(w_j, lower = 0, upper = 1, len = 1, .var.name = "w_j")

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- getPriorParametersExNex(target_rates, tau_scale, n_worth, w_j)[[1]]

  prior_parameters$mu_mean <- 0
  prior_parameters$mu_j    <- rep(0, length(target_rates))

  prior_parameters_list <- list (exnex_adj = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersExNexAdj
#' @md
#' @description This function sets prior parameters for the analysis method `"exnex_adj"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param mu_mean A numeric for the mean of \eqn{\mu}
#' @param mu_sd A positive numeric for the standard deviation of \eqn{\mu}
#' @param tau_scale A positive numeric for the scale parameter of \eqn{\tau}
#' @param mu_j A vector of numerics for the means \eqn{\mu_j}
#' @param tau_j A vector of positive numerics for the standard deviations \eqn{\tau_j}
#' @param w_j A numeric in `(0, 1)` for the weight of the Ex component
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' This function sets the prior parameters for the method ExNex Adjusted, which combines
#' the approach proposed by Neuenschwander et al. (2016) and the approach proposed by
#' Berry et al. (2013).
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_exnex_adj <- setPriorParametersExNexAdj(0, 1, 2, c(4, 5), c(6, 7), 0.8)
#' @rdname setPriorParametersExNexAdj
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersExNexAdj <- function (

  mu_mean,
  mu_sd,
  tau_scale,

  mu_j,
  tau_j,

  w_j

) {
  
  checkmate::assert_numeric(mu_mean, any.missing = FALSE, .var.name = "mu_mean")
  
  checkmate::assert_numeric(mu_sd, lower = 0, any.missing = FALSE, .var.name = "mu_sd")
  checkmate::assertTRUE(all(mu_sd > 0), .var.name = "mu_sd")
  
  checkmate::assertNumber(tau_scale, .var.name = "tau_scale")
  checkmate::assertTRUE(tau_scale > 0, .var.name = "tau_scale")
  
  checkmate::assert_numeric(mu_j, any.missing = FALSE, .var.name = "mu_j")
  
  checkmate::assert_numeric(tau_j, any.missing = FALSE, .var.name = "tau_j")
  checkmate::assertTRUE(all(tau_j > 0), .var.name = "tau_j")
  
  checkmate::assert_numeric(w_j, lower = 0, upper = 1, any.missing = FALSE, .var.name = "w_j")
  
  checkmate::assert_true(length(mu_mean) == length(mu_sd), .var.name = "'mu_mean' and 'mu_sd' must have same length")
  
  checkmate::assert_true(length(mu_j) == length(tau_j), .var.name = "'mu_j' and 'tau_j' must have same length")
  
  if (length(mu_mean) > 1) {
    checkmate::assert_true(length(w_j) == length(mu_mean) + 1, .var.name =
                             "'w_j' must have length equal to length(mu_mean) + 1 if length(mu_mean) > 1")
  } else {
    checkmate::assert_true(length(w_j) %in% c(1, 2), .var.name =
                             "'w_j' must have length 1 or 2 if length(mu_mean) = 1")
  }
  
  # Added this check from setparameters ExNex
  if (length(w_j) > 1) {
    checkmate::assert_true(isTRUE(all.equal(sum(w_j), 1)), .var.name =
                             "Sum over items in 'w_j' must equal 1 if length(w_j) > 1")
  }

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters_list <- setPriorParametersExNex(mu_mean, mu_sd, tau_scale, mu_j, tau_j, w_j)
  names(prior_parameters_list) <- "exnex_adj"

  return (prior_parameters_list)

}

## pooled ####

getPriorParametersPooled <- function (

  target_rates,
  n_worth = 1

) {
  
  checkmate::assertNumeric(target_rates, any.missing = FALSE, .var.name = "target_rates")
  checkmate::assertTRUE(all(target_rates > 0 & target_rates < 1), .var.name = "target_rates")
  
  checkmate::assertInt(n_worth, lower = 1, .var.name = "n_worth")
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  target_rate_min_var <- target_rates[abs(target_rates - 0.5) == min(abs(target_rates - 0.5))][1]

  a <- target_rate_min_var * n_worth
  b <- (1 - target_rate_min_var) * n_worth

  prior_parameters <- list(a = a, b = b)

  prior_parameters_list        <- list(pooled = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersPooled
#' @md
#' @description This function sets prior parameters for the analysis method `"pooled"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param a A positive numeric for \eqn{\alpha}
#' @param b A positive numeric for \eqn{\beta}
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' The method `"pooled"` is a beta-binomial model that pools all cohorts.
#' The prior parameters are the scale parameters of the beta prior distribution.
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_pooled <- setPriorParametersPooled(1, 2)
#' @rdname setPriorParametersPooled
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersStratified}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersPooled <- function (

  a,
  b

) {

  checkmate::assertNumber(a, .var.name = "a")
  checkmate::assertTRUE(a > 0, .var.name = "a")
  
  checkmate::assertNumber(b, .var.name = "b")
  checkmate::assertTRUE(b > 0, .var.name = "b")

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- list(a = a, b = b)

  prior_parameters_list        <- list(pooled = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

## stratified ####

getPriorParametersStratified <- function (

  target_rates,
  n_worth = 1

) {
  
  checkmate::assertNumeric(target_rates, any.missing = FALSE, .var.name = "target_rates")
  checkmate::assertTRUE(all(target_rates > 0 & target_rates < 1), .var.name = "target_rates")
  
  checkmate::assertInt(n_worth, lower = 1, .var.name = "n_worth")

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  a_j <- target_rates * n_worth
  b_j <- (1 - target_rates) * n_worth

  prior_parameters <- list(a_j = a_j, b_j = b_j)

  prior_parameters_list        <- list(stratified = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}

#' @title setPriorParametersStratified
#' @md
#' @description This function sets prior parameters for the analysis method `"stratified"`
#' for use in \code{\link[bhmbasket]{performAnalyses}}.
#' @param a_j A vector of positive numerics for \eqn{\alpha}
#' @param b_j A vector of positive numerics for \eqn{\beta}
#' @return A list with prior parameters of class `prior_parameters_list`
#' @details
#' The method `"stratified"` is a beta-binomial model that assesses each cohort individually.
#' The prior parameters are the scale parameters of the beta prior distributions.
#' @author Stephan Wojciekowski
#' @examples
#'  prior_parameters_pooled <- setPriorParametersStratified(c(1, 2), c(3, 4))
#' @rdname setPriorParametersStratified
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#'  \code{\link[bhmbasket]{combinePriorParameters}}
#'  \code{\link[bhmbasket]{setPriorParametersBerry}}
#'  \code{\link[bhmbasket]{setPriorParametersExNex}}
#'  \code{\link[bhmbasket]{setPriorParametersExNexAdj}}
#'  \code{\link[bhmbasket]{setPriorParametersPooled}}
#'  \code{\link[bhmbasket]{getMuVar}}
#' @export
setPriorParametersStratified <- function (

  a_j,
  b_j

) {
  
  checkmate::assertNumeric(a_j, any.missing = FALSE, .var.name = "a_j")
  checkmate::assertTRUE(all(a_j > 0), .var.name = "a_j")
  
  checkmate::assertNumeric(b_j, any.missing = FALSE, .var.name = "b_j")
  checkmate::assertTRUE(all(b_j > 0), .var.name = "b_j")
  
  # Ensure same length
  checkmate::assertTRUE(
    length(a_j) == length(b_j),
    .var.name = "a_j and b_j",
  )
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  prior_parameters <- list(a_j = a_j, b_j = b_j)

  prior_parameters_list        <- list(stratified = prior_parameters)
  class(prior_parameters_list) <- "prior_parameters_list"

  return (prior_parameters_list)

}


