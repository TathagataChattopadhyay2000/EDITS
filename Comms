## Test: mapUniqueTrials with pooled backend preserves naive per-trial quantiles
## Input:
##   - One scenario with several trials and 2 cohorts (generated via getScenario()).
##   - trials_unique_calc derived from getUniqueTrials(), with
##     applicable_previous_trials = FALSE so that all unique patterns are treated
##     as newly analysed.
##   - method_quantiles_list for method "pooled" containing posterior quantile
##     matrices computed only for the unique trial patterns using getPostQuantiles().
##
## Naive reference:
##   - For each original trial i (row i of n_responders, n_subjects), we call
##     getPostQuantiles(method_name = "pooled", ...) directly and store the
##     resulting single-trial quantile matrix in naive_list[[i]].
##
## Expected output:
##   - mapUniqueTrials returns a list with one element named "scenario_1".
##   - scenario_1$pooled is a list of length equal to the original number of trials.
##   - For each trial i, scenario_1$pooled[[i]] is exactly equal to
##     naive_list[[i]] (the per-trial quantile matrix from the naive analysis).
##
## Why this test:
##   - For the pooled design, getPostQuantiles() is deterministic given
##     (n_responders, n_subjects) and j_data.
##   - mapUniqueTrials must use hashing + unique trial patterns to avoid
##     redundant computations, but still reproduce the same per-trial quantiles
##     as the naive approach that analyses each trial separately.
