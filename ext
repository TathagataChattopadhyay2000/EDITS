### numeric ####

is.positive.numeric <- function (x) {

  return (is.numeric(x) && all(x > 0))

}

is.numeric.in.zero.one <- function (x) {

  return (is.numeric(x) && all(x > 0) && all(x < 1))

}

is.single.numeric <- function (x) {

  return (is.numeric(x) && length(x) == 1)

}

is.single.positive.numeric <- function (x) {

  return (is.single.numeric(x) && x > 0)

}

is.single.numeric.in.zero.one <- function (x) {

  return (is.single.numeric(x) && is.numeric.in.zero.one(x))

}

### whole number ####

is.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  if (is.numeric(x)) {

    return (abs(x - round(x)) < tol)

  } else {

    return (FALSE)

  }

}

is.positive.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  return (all(is.wholenumber(x, tol = tol)) && all(x > 0))

}

is.non.negative.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  return (all(is.wholenumber(x, tol = tol)) && all(x >= 0))

}

is.single.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  return (all(is.wholenumber(x, tol = tol)) && length(x) == 1)

}

is.single.non.negative.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  return (is.single.wholenumber(x, tol = tol) && all(is.non.negative.wholenumber(x, tol = tol)))

}

is.single.positive.wholenumber <- function (x, tol = .Machine$double.eps^0.5) {

  return (is.single.wholenumber(x, tol = tol) && all(is.positive.wholenumber(x, tol = tol)))

}


### evidence levels
check.evidence.levels <- function (
    
  evidence_levels,
  cohort_names,
  analyses_list,
  error_evidence_levels
  
) {
  
  checkmate::assert_true(
    length(evidence_levels) == length(cohort_names),
    .var = "The 'evidence_levels' and the 'cohort_names' must have the same length"
  )
  
  
  if (is.character(evidence_levels)) {
    
    mean_index <- evidence_levels == "mean"
    
    evidence_levels_numeric <- tryCatch({
      as.numeric(evidence_levels[!mean_index])
    }, warning = function(w) w)
    
    checkmate::assert_false(
      inherits(evidence_levels_numeric, "warning"),
      .var = "The only string allowed for the argument 'evidence_levels' is 'mean'"
    )
    
    
  } else {
    
    evidence_levels_numeric <- evidence_levels
    
  }
  
  checkmate::assert_numeric(
    evidence_levels_numeric,
    lower = 0, upper = 1, any.missing = FALSE,
    .var = error_evidence_levels
  )
  
  available_quantiles <- round(analyses_list[[1]]$analysis_parameters$quantiles, 9)
  asked_quantiles     <- round(1 - evidence_levels_numeric, 9)
  
  checkmate::assert_true(
    all(asked_quantiles %in% available_quantiles),
    .var = paste(
      "The 'evidence_levels' must have matches",
      "in the 'evidence_levels' provided to the call performAnalyses()",
      "that created the 'analyses_list'"
    )
  )
}

### functions ####

checkForParallelBackend <- function () {
  
  "%dopar%" <- foreach::"%dopar%"
  if(!foreach::getDoParRegistered()) {
    
    message("\nCaution: No parallel backend detected for the 'foreach' framework.",
            " For execution in parallel, register a parallel backend, e.g. with:\n",
            "   doFuture::registerDoFuture()\n",
            "   future::plan(future::multisession)\n")
    
    # foreach if without parallel backend gives a warning, warning is being
    # displayed only once, should be repeated anyway, message better
    
    tt <- suppressWarnings(foreach::foreach(k = 1:2) %dopar% {k^k^k})
    rm(tt)
    
  }
  
}
