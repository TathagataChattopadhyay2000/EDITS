getGoDecisions(
  analyses_list,
  cohort_names,
  evidence_levels,
  boundary_rules,
  overall_min_gos = 1
)
Arguments
analyses_list	
An object of class analysis_list, as created with performAnalyses

cohort_names	
A vector of strings with the names of the cohorts, e.g. c('p_1', 'p_2')

evidence_levels	
A vector of numerics in (0, 1) for the posterior probability thresholds for the cohorts. Will be recycled to match the number of methods in the analyses_list

boundary_rules	
A quote of a vector for the boundary rules, quote(c(...)), see details. The number of decisions to be taken must match the number of cohorts. Will be recycled to match the number of methods in the analyses_list

overall_min_gos	
A positive integer for the minimum number of cohort-wise go decisions required for an overall go decision Default: 1

Details
This function applies decision rules of the following type to the outcomes of (simulated) basket trials with binary endpoints:

P
(
p
j
∣
d
a
t
a
>
p
B
,
j
)
>
γ
,
P(p 
j
​
 ∣data>p 
B,j
​
 )>γ,

where 
p
j
∣
d
a
t
a
p 
j
​
 ∣data is the posterior response rate of cohort 
j
j, 
p
B
,
j
p 
B,j
​
  is the response rate boundary of cohort 
j
j, and 
γ
γ is the evidence level. This rule can equivalently be written as

q
1
−
γ
,
j
>
p
B
,
j
,
q 
1−γ,j
​
 >p 
B,j
​
 ,

where 
q
1
−
γ
,
j
q 
1−γ,j
​
  is the 
1
−
γ
1−γ-quantile of the posterior response rate of cohort 
j
j.

The arguments cohort_names and evidence_levels determine 
q
1
−
γ
,
j
q 
1−γ,j
​
 , where the entries of cohort_names and evidence_levels are matched corresponding to their order.

The argument boundary_rules provides the rules that describe what should happen with the posterior quantiles 
q
1
−
γ
,
j
q 
1−γ,j
​
 . The first posterior quantile determined by the first items of cohort_names and evidence_levels is referred to as x[1], the second as x[2], etc. Using the quote(c(...))-notation, many different rules can be implemented. A decision rule for only one cohort would be boundary_rules = quote(c(x[1] > 0.1)), cohort_names = 'p_1', and evidence_levels = 0.5, which implements the rule 
P
(
p
1
∣
d
a
t
a
>
0.1
)
>
0.5
P(p 
1
​
 ∣data>0.1)>0.5. The number of decisions to be taken must match the number of cohorts, i.e. for each cohort there must be a decision rule in the vector separated by a comma. See the example section for a decision rule for more than one cohort and the example of negateGoDecisions for the implementation of a more complex decision rule.

Value
An object of class decision_list

Author(s)
Stephan Wojciekowski

See Also
performAnalyses getGoProbabilities negateGoDecisions continueRecruitment

Examples
Run examples

scenarios_list <- simulateScenarios(
  n_subjects_list     = list(c(10, 20, 30)),
  response_rates_list = list(c(0.1, 0.1, 0.9)),
  n_trials            = 10)

analyses_list <- performAnalyses(
  scenario_list      = scenarios_list,
  target_rates       = rep(0.5, 3),
  n_mcmc_iterations  = 100)

## Decision rule for more than one cohort
decisions_list <- getGoDecisions(
  analyses_list   = analyses_list,
  cohort_names    = c("p_1", "p_2", "p_3"),
  evidence_levels = c(0.5, 0.5, 0.8),
  boundary_rules  = quote(c(x[1] > 0.7, x[2] < 0.3, x[3] < 0.6)))

## Decision rule for only two of the three cohorts
decisions_list <- getGoDecisions(
  analyses_list   = analyses_list,
  cohort_names    = c("p_1", "p_3"),
  evidence_levels = c(0.5, 0.8),
  boundary_rules  = quote(c(x[1] > 0.7, TRUE, x[3] < 0.6)),
  overall_min_gos = 2L)

## Different decision rules for each method
## This works the same way for the different evidence_levels
decisions_list <- getGoDecisions(
  analyses_list   = analyses_list,
  cohort_names    = c("p_1", "p_2", "p_3"),
  evidence_levels = c(0.5, 0.5, 0.8),
  boundary_rules  = list(quote(c(x[1] > 0.1, x[2] < 0.5, x[3] < 0.1)),  # "berry"
                         quote(c(x[1] > 0.2, x[2] < 0.4, x[3] < 0.2)),  # "exnex"
                         quote(c(x[1] > 0.3, x[2] < 0.3, x[3] < 0.3)),  # "exnex_adj"
                         quote(c(x[1] > 0.4, x[2] < 0.2, x[3] < 0.4)),  # "pooled"
                         quote(c(x[1] > 0.5, x[2] < 0.1, x[3] < 0.5)))) # "str
