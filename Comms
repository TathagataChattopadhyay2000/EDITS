doFuture::registerDoFuture()
future::plan(future::sequential())

library(dplyr)
library(plotly)

# Design settings --------------------------------------------------------------

p0           <- c(0.40, 0.40)   # null true response rates
p1           <- c(0.55, 0.55)   # alternative true response rates
p_beta_vec   <- c(0.50, 0.50)   # clinical boundary
type_1_error <- 0.20            # allowed Type I error
power_min    <- 0.80            # required power
n_trials_oc  <- 100             # simulated trials per (n, gamma)
method_name  <- "stratified"    # backend used for OC evaluation

# Grids for n and gamma --------------------------------------------------------

n_grid_coarse     <- seq(10, 40, by = 5)
gamma_grid_coarse <- seq(0.5, 0.95, by = 0.05)

set.seed(2026)

# Coarse grid: directly compute OC table ---------------------------------------

oc_results_coarse <- expand.grid(
  n     = n_grid_coarse,
  gamma = gamma_grid_coarse
)

oc_results_coarse$type_1_error_hat <- NA_real_
oc_results_coarse$power_hat        <- NA_real_

for (i in seq_len(nrow(oc_results_coarse))) {
  n_i     <- oc_results_coarse$n[i]
  gamma_i <- oc_results_coarse$gamma[i]
  
  # ----- Type I error under p0 -----
  scen0 <- simulateScenarios(
    n_subjects_list     = list(c(n_i, n_i)),
    response_rates_list = list(p0),
    n_trials            = n_trials_oc
  )
  
  analyses0 <- performAnalyses(
    scenario_list      = scen0,
    evidence_levels    = seq(0.5, 0.95, by = 0.01),
    target_rates       = p_beta_vec,
    method_names       = method_name,
    n_mcmc_iterations  = 100,
    verbose            = FALSE
  )
  
  decisions0 <- getGoDecisions(
    analyses_list   = analyses0,
    cohort_names    = c("p_1", "p_2"),
    evidence_levels = c(gamma_i, gamma_i),
    boundary_rules  = quote(c(
      x[1] > p_beta_vec[1],
      x[2] > p_beta_vec[2]
    )),
    overall_min_gos = 1
  )
  
  go_probs0 <- getGoProbabilities(decisions0)
  go_mat0   <- go_probs0[[method_name]][["scenario_1"]]
  oc_results_coarse$type_1_error_hat[i] <- go_mat0["Go", "overall"]
  
  # ----- Power under p1 -----
  scen1 <- simulateScenarios(
    n_subjects_list     = list(c(n_i, n_i)),
    response_rates_list = list(p1),
    n_trials            = n_trials_oc
  )
  
  analyses1 <- performAnalyses(
    scenario_list      = scen1,
    evidence_levels    = seq(0.5, 0.95, by = 0.01),
    target_rates       = p_beta_vec,
    method_names       = method_name,
    n_mcmc_iterations  = 100,
    verbose            = FALSE
  )
  
  decisions1 <- getGoDecisions(
    analyses_list   = analyses1,
    cohort_names    = c("p_1", "p_2"),
    evidence_levels = c(gamma_i, gamma_i),
    boundary_rules  = quote(c(
      x[1] > p_beta_vec[1],
      x[2] > p_beta_vec[2]
    )),
    overall_min_gos = 1
  )
  
  go_probs1 <- getGoProbabilities(decisions1)
  go_mat1   <- go_probs1[[method_name]][["scenario_1"]]
  oc_results_coarse$power_hat[i] <- go_mat1["Go", "overall"]
}

oc_results_coarse$feasible <- with(
  oc_results_coarse,
  type_1_error_hat <= type_1_error & power_hat >= power_min
)
oc_results_coarse$resolution <- "Coarse"

# Fine grid: define from feasible coarse region and compute directly -----------

feas_coarse <- oc_results_coarse[oc_results_coarse$feasible, , drop = FALSE]

if (nrow(feas_coarse) > 0L) {
  n_range     <- range(feas_coarse$n)
  gamma_range <- range(feas_coarse$gamma)
  
  n_grid_fine <- seq(
    from = max(10, n_range[1] - 2),
    to   = min(40, n_range[2] + 2),
    by   = 1
  )
  
  gamma_grid_fine <- seq(
    from = max(0.5,  gamma_range[1] - 0.05),
    to   = min(0.95, gamma_range[2] + 0.05),
    by   = 0.01
  )
  
  oc_results_fine <- expand.grid(
    n     = n_grid_fine,
    gamma = gamma_grid_fine
  )
  
  oc_results_fine$type_1_error_hat <- NA_real_
  oc_results_fine$power_hat        <- NA_real_
  
  for (i in seq_len(nrow(oc_results_fine))) {
    n_i     <- oc_results_fine$n[i]
    gamma_i <- oc_results_fine$gamma[i]
    
    # ----- Type I error under p0 -----
    scen0 <- simulateScenarios(
      n_subjects_list     = list(c(n_i, n_i)),
      response_rates_list = list(p0),
      n_trials            = n_trials_oc
    )
    
    analyses0 <- performAnalyses(
      scenario_list      = scen0,
      evidence_levels    = seq(0.5, 0.95, by = 0.01),
      target_rates       = p_beta_vec,
      method_names       = method_name,
      n_mcmc_iterations  = 100,
      verbose            = FALSE
    )
    
    decisions0 <- getGoDecisions(
      analyses_list   = analyses0,
      cohort_names    = c("p_1", "p_2"),
      evidence_levels = c(gamma_i, gamma_i),
      boundary_rules  = quote(c(
        x[1] > p_beta_vec[1],
        x[2] > p_beta_vec[2]
      )),
      overall_min_gos = 1
    )
    
    go_probs0 <- getGoProbabilities(decisions0)
    go_mat0   <- go_probs0[[method_name]][["scenario_1"]]
    oc_results_fine$type_1_error_hat[i] <- go_mat0["Go", "overall"]
    
    # ----- Power under p1 -----
    scen1 <- simulateScenarios(
      n_subjects_list     = list(c(n_i, n_i)),
      response_rates_list = list(p1),
      n_trials            = n_trials_oc
    )
    
    analyses1 <- performAnalyses(
      scenario_list      = scen1,
      evidence_levels    = seq(0.5, 0.95, by = 0.01),
      target_rates       = p_beta_vec,
      method_names       = method_name,
      n_mcmc_iterations  = 100,
      verbose            = FALSE
    )
    
    decisions1 <- getGoDecisions(
      analyses_list   = analyses1,
      cohort_names    = c("p_1", "p_2"),
      evidence_levels = c(gamma_i, gamma_i),
      boundary_rules  = quote(c(
        x[1] > p_beta_vec[1],
        x[2] > p_beta_vec[2]
      )),
      overall_min_gos = 1
    )
    
    go_probs1 <- getGoProbabilities(decisions1)
    go_mat1   <- go_probs1[[method_name]][["scenario_1"]]
    oc_results_fine$power_hat[i] <- go_mat1["Go", "overall"]
  }
  
  oc_results_fine$feasible <- with(
    oc_results_fine,
    type_1_error_hat <= type_1_error & power_hat >= power_min
  )
  oc_results_fine$resolution <- "Fine"
  
} else {
  oc_results_fine <- oc_results_coarse[FALSE, , drop = FALSE]
  oc_results_fine$resolution <- "Fine"
}

# Combine coarse and fine, label feasibility, compute boundaries --------------

oc_all <- bind_rows(oc_results_coarse, oc_results_fine)

oc_all$feasible_factor <- ifelse(oc_all$feasible, "Feasible", "Not feasible")
oc_all$feasible_factor <- factor(
  oc_all$feasible_factor,
  levels = c("Not feasible", "Feasible")
)

calc_boundaries <- function(df) {
  feas_only <- df[df$feasible, , drop = FALSE]
  if (nrow(feas_only) == 0L) {
    return(df[FALSE, , drop = FALSE])
  }
  
  tmp_gamma <- aggregate(n ~ gamma, data = feas_only, FUN = min)
  min_n_per_gamma <- merge(
    tmp_gamma,
    feas_only,
    by = c("gamma", "n"),
    all.x = TRUE,
    sort = TRUE
  )
  
  tmp_n <- aggregate(gamma ~ n, data = feas_only, FUN = min)
  min_gamma_per_n <- merge(
    tmp_n,
    feas_only,
    by = c("n", "gamma"),
    all.x = TRUE,
    sort = TRUE
  )
  
  list(
    min_n_per_gamma = min_n_per_gamma,
    min_gamma_per_n = min_gamma_per_n
  )
}

bnd_coarse <- calc_boundaries(oc_results_coarse)
bnd_fine   <- calc_boundaries(oc_results_fine)

md_coarse <- oc_all[oc_all$resolution == "Coarse", , drop = FALSE]
md_fine   <- oc_all[oc_all$resolution == "Fine",   , drop = FALSE]

md_coarse_feas  <- md_coarse %>% filter(feasible_factor == "Feasible")
md_coarse_nfeas <- md_coarse %>% filter(feasible_factor == "Not feasible")
md_fine_feas    <- md_fine   %>% filter(feasible_factor == "Feasible")
md_fine_nfeas   <- md_fine   %>% filter(feasible_factor == "Not feasible")

# Plotly (same as before) ------------------------------------------------------

fig <- plot_ly() %>%
  add_trace(
    data  = md_coarse_feas,
    x     = ~n, y = ~gamma,
    type  = "scatter", mode = "markers",
    marker = list(color = "green"),
    name  = "Coarse — Feasible",
    legendgroup = "coarse",
    hoverinfo = "text",
    text  = ~paste0(
      "Resolution = Coarse",
      "<br>n = ", n,
      "<br>gamma = ", round(gamma, 3),
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3),
      "<br>Feasible = ", feasible
    ),
    visible = TRUE
  ) %>%
  add_trace(
    data  = md_coarse_nfeas,
    x     = ~n, y = ~gamma,
    type  = "scatter", mode = "markers",
    marker = list(color = "red"),
    name  = "Coarse — Not feasible",
    legendgroup = "coarse",
    hoverinfo = "text",
    text  = ~paste0(
      "Resolution = Coarse",
      "<br>n = ", n,
      "<br>gamma = ", round(gamma, 3),
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3),
      "<br>Feasible = ", feasible
    ),
    visible = TRUE
  ) %>%
  add_trace(
    data   = bnd_coarse$min_n_per_gamma,
    x      = ~n, y = ~gamma,
    type   = "scatter", mode = "lines+markers",
    inherit = FALSE,
    line   = list(width = 2),
    marker = list(size = 8, symbol = "x", color = "black"),
    name   = "Coarse boundary",
    legendgroup = "coarse",
    hoverinfo = "text",
    text = ~paste0(
      "Resolution = Coarse",
      "<br>gamma = ", round(gamma, 3),
      "<br>min n = ", n,
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3)
    ),
    showlegend = FALSE,
    visible = TRUE
  ) %>%
  add_trace(
    data  = md_fine_feas,
    x     = ~n, y = ~gamma,
    type  = "scatter", mode = "markers",
    marker = list(color = "green"),
    name  = "Fine — Feasible",
    legendgroup = "fine",
    hoverinfo = "text",
    text  = ~paste0(
      "Resolution = Fine",
      "<br>n = ", n,
      "<br>gamma = ", round(gamma, 3),
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3),
      "<br>Feasible = ", feasible
    ),
    visible = FALSE
  ) %>%
  add_trace(
    data  = md_fine_nfeas,
    x     = ~n, y = ~gamma,
    type  = "scatter", mode = "markers",
    marker = list(color = "red"),
    name  = "Fine — Not feasible",
    legendgroup = "fine",
    hoverinfo = "text",
    text  = ~paste0(
      "Resolution = Fine",
      "<br>n = ", n,
      "<br>gamma = ", round(gamma, 3),
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3),
      "<br>Feasible = ", feasible
    ),
    visible = FALSE
  ) %>%
  add_trace(
    data   = bnd_fine$min_n_per_gamma,
    x      = ~n, y = ~gamma,
    type   = "scatter", mode = "lines+markers",
    inherit = FALSE,
    line   = list(width = 2),
    marker = list(size = 8, symbol = "x", color = "black"),
    name   = "Fine boundary",
    legendgroup = "fine",
    hoverinfo = "text",
    text = ~paste0(
      "Resolution = Fine",
      "<br>gamma = ", round(gamma, 3),
      "<br>min n = ", n,
      "<br>Type I error = ", round(type_1_error_hat, 3),
      "<br>Power = ", round(power_hat, 3)
    ),
    showlegend = FALSE,
    visible = FALSE
  ) %>%
  layout(
    title = "Feasible vs Non-feasible Designs (stratified, 2 cohorts)",
    xaxis = list(title = "Sample size per cohort (n)", range = c(10, 40), fixedrange = TRUE),
    yaxis = list(title = "Evidence level (gamma)", range = c(0.5, 0.95), fixedrange = TRUE),
    legend = list(title = list(text = "Designs")),
    updatemenus = list(
      list(
        type = "dropdown", x = 1.12, y = 1,
        buttons = list(
          list(
            label = "Coarse only",
            method = "update",
            args = list(
              list(visible = c(TRUE, TRUE, TRUE,  FALSE, FALSE, FALSE)),
              list(title = "Feasible vs Non-feasible — Coarse")
            )
          ),
          list(
            label = "Fine only",
            method = "update",
            args = list(
              list(visible = c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE)),
              list(title = "Feasible vs Non-feasible — Fine")
            )
          ),
          list(
            label = "Both",
            method = "update",
            args = list(
              list(visible = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE)),
              list(title = "Feasible vs Non-feasible — Coarse & Fine")
            )
          )
        )
      ),
      list(
        type = "dropdown", x = 1.12, y = 0.92,
        buttons = list(
          list(
            label = "Feasible only",
            method = "restyle",
            args = list("marker.opacity", list(1, 0, 1, 1, 0, 1))
          ),
          list(
            label = "Not feasible only",
            method = "restyle",
            args = list("marker.opacity", list(0, 1, 1, 0, 1, 1))
          ),
          list(
            label = "Both feasibilities",
            method = "restyle",
            args = list("marker.opacity", list(1, 1, 1, 1, 1, 1))
          )
        )
      )
    )
  )

fig
