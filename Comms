test_that("mapUniqueTrials preserves per-trial posteriors vs naive computation (pooled)", {
  foreach::registerDoSEQ()
  set.seed(123)

  # Build a single scenario with 4 trials and 2 cohorts,
  # where trials 1 & 2 share the same pattern, and 3 & 4 share another one.
  scene <- getScenario(
    n_subjects     = c(10, 20),
    response_rates = c(0.4, 0.6),
    n_trials       = 4
  )

  if (is.null(scene$scenario_number)) {
    scene$scenario_number <- 1L
  }

  # Overwrite responder/subject counts to enforce duplicated patterns
  n_subj <- rbind(
    c(10, 20),  # trial 1
    c(10, 20),  # trial 2 (duplicate of trial 1)
    c(15, 25),  # trial 3
    c(15, 25)   # trial 4 (duplicate of trial 3)
  )
  n_resp <- rbind(
    c(3, 7),    # trial 1
    c(3, 7),    # trial 2 (duplicate of trial 1)
    c(5, 9),    # trial 3
    c(5, 9)     # trial 4 (duplicate of trial 3)
  )

  scene$n_subjects <- n_subj
  scene$n_responders <- n_resp
  scene$n_trials <- nrow(n_subj)

  scenario_list <- list(scenario_1 = scene)
  class(scenario_list) <- "scenario_list"

  n_subj_mat <- scene$n_subjects
  n_resp_mat <- scene$n_responders
  n_trials   <- nrow(n_subj_mat)
  n_coh      <- ncol(n_subj_mat)

  # --- Naive per-trial computation (one posterior per original trial) ----

  quantiles <- c(0.025, 0.5, 0.975)
  j_data    <- list(a = 1, b = 1)  # Beta(1,1) prior for pooled model

  naive_list <- vector("list", length = n_trials)

  for (i in seq_len(n_trials)) {
    scenario_data_i <- list(
      n_subjects   = n_subj_mat[i, , drop = FALSE],
      n_responders = n_resp_mat[i, , drop = FALSE]
    )

    naive_list[[i]] <- getPostQuantiles(
      method_name       = "pooled",
      quantiles         = quantiles,
      scenario_data     = scenario_data_i,
      calc_differences  = NULL,
      j_parameters      = NULL,
      j_model_file      = NULL,
      j_data            = j_data,
      n_mcmc_iterations = 1000,
      save_path         = NULL,
      save_trial        = NULL
    )[[1]]
  }

  # --- Unique-pattern computation (run only once per distinct pattern) ----

  trials_unique <- getUniqueTrials(scenario_list)
  # trials_unique: [responders | subjects | go_flag]
  n_coh_u <- (ncol(trials_unique) - 1L) / 2L
  expect_equal(n_coh_u, n_coh)

  applicable_previous_trials <- FALSE

  calc_trial_indices <- rep(TRUE, nrow(trials_unique))
  trials_unique_calc <- trials_unique[calc_trial_indices, -ncol(trials_unique), drop = FALSE]

  n_resp_unique <- trials_unique_calc[, seq_len(n_coh),         drop = FALSE]
  n_subj_unique <- trials_unique_calc[, seq_len(n_coh) + n_coh, drop = FALSE]

  # Compute pooled quantiles once for each unique trial pattern
  unique_quantiles <- getPostQuantiles(
    method_name       = "pooled",
    quantiles         = quantiles,
    scenario_data     = list(
      n_subjects   = n_subj_unique,
      n_responders = n_resp_unique
    ),
    calc_differences  = NULL,
    j_parameters      = NULL,
    j_model_file      = NULL,
    j_data            = j_data,
    n_mcmc_iterations = 1000,
    save_path         = NULL,
    save_trial        = NULL
  )

  method_quantiles_list <- list(
    pooled = unique_quantiles
  )

  # --- Map unique results back to all trials via mapUniqueTrials ---------

  out <- mapUniqueTrials(
    scenario_list              = scenario_list,
    method_quantiles_list      = method_quantiles_list,
    trials_unique_calc         = trials_unique_calc,
    applicable_previous_trials = applicable_previous_trials
  )

  expect_type(out, "list")
  expect_identical(names(out), "scenario_1")

  scen1_out <- out[["scenario_1"]]
  expect_true(is.list(scen1_out))
  expect_true("pooled" %in% names(scen1_out))

  # Should now have one quantile matrix per *original* trial
  expect_equal(length(scen1_out$pooled), n_trials)

  # For each original trial, the mapped quantiles should match the naive ones
  for (i in seq_len(n_trials)) {
    expect_equal(
      scen1_out$pooled[[i]],
      naive_list[[i]],
      tolerance = 1e-12
    )
  }
})
