is.scenario_list_normal <- function (x) {
  if (missing(x)) stop("Please provide an object for the argument 'x'")
  inherits(x, "scenario_list_normal")
}

getScenarioNormal <- function(
    n_subjects,
    means,
    sd,
    cohort_names = seq_along(n_subjects),
    n_trials     = 1e4
) {
  
  checkmate::assert_integerish(
    n_subjects,
    lower       = 1,
    any.missing = FALSE,
    .var.name   = "n_subjects"
  )
  
  checkmate::assert_numeric(
    means,
    any.missing = FALSE,
    len         = length(n_subjects),
    .var.name   = "means"
  )
  
  checkmate::assert_numeric(
    sd,
    any.missing = FALSE,
    lower       = 0,
    .var.name   = "sd"
  )
  
  # allow scalar sd or per-cohort sd
  if (length(sd) == 1L) {
    sd_vec <- rep(sd, length(n_subjects))
  } else {
    checkmate::assert_true(
      length(sd) == length(n_subjects),
      .var.name = "sd must be length 1 or length(n_subjects)"
    )
    sd_vec <- sd
  }
  
  checkmate::assert_integerish(
    n_trials,
    lower       = 1,
    any.missing = FALSE,
    len         = 1L,
    .var.name   = "n_trials"
  )
  
  checkmate::assert_true(
    length(cohort_names) == length(n_subjects),
    .var.name = "cohort_names must match length of n_subjects"
  )
  
  K                <- length(n_subjects)
  cohort_names_chr <- as.character(cohort_names)
  
  # matrix of planned sample sizes (same as binary version, just no responders)
  n_subjects_mat <- matrix(
    n_subjects,
    nrow = n_trials,
    ncol = K,
    byrow = TRUE
  )
  colnames(n_subjects_mat) <- paste0("n_", cohort_names_chr)
  
  # trials[[t]]$y_list is a list of length K, each element is a numeric vector
  # of length n_subjects[k] with Normal(mean_k, sd_k^2) data
  trials <- vector("list", n_trials)
  
  for (t in seq_len(n_trials)) {
    y_list <- vector("list", K)
    for (k in seq_len(K)) {
      y_list[[k]] <- stats::rnorm(
        n    = n_subjects[k],
        mean = means[k],
        sd   = sd_vec[k]
      )
    }
    names(y_list) <- paste0("c_", cohort_names_chr)
    
    trials[[t]] <- list(
      y_list     = y_list,
      n_subjects = n_subjects   # per-trial copy (optional, but handy)
    )
  }
  
  previous_gos <- matrix(
    TRUE,
    byrow = TRUE,
    ncol  = K + 1L,
    nrow  = n_trials
  )
  colnames(previous_gos) <- c("overall", paste0("decision_", cohort_names_chr))
  
  scenario_data <- list(
    n_subjects        = n_subjects_mat,   # design/sample size per trial
    means             = means,           # true means per cohort
    sd                = sd_vec,          # sd per cohort
    trials            = trials,          # list of outcome data
    previous_analyses = list(
      go_decisions   = previous_gos,
      post_quantiles = NULL
    ),
    n_trials          = n_trials
  )
  
  return(scenario_data)
}

#' @title simulateScenariosNormal
#' @description Create scenarios with normal endpoints for analysis with
#'   \code{performAnalysesNormal()}.
#' @param n_subjects_list A list that contains for each scenario a vector for
#'   the number of subjects per cohort. A single vector can be provided if all
#'   scenarios should have the same number of subjects.
#' @param mean_list A list that contains for each scenario a numeric vector
#'   with the true means per cohort.
#' @param sd A positive numeric (common SD for all cohorts and scenarios) or
#'   a list of numeric vectors (one per scenario, same length as mean vector).
#' @param scenario_numbers A vector of positive integers naming the scenarios,
#'   Default: \code{seq_along(mean_list)}.
#' @param n_trials A positive integer for the number of simulated trial
#'   realizations per scenario, Default: \code{10000}.
#'   If \code{n_trials} is present in \code{.GlobalEnv} and
#'   \code{missing(n_trials)}, the globally available value will be used.
#' @return An object of class \code{scenario_list_normal}.
#'   Each scenario contains:
#'   \itemize{
#'     \item \code{scenario_number}
#'     \item \code{n_subjects}: matrix (n_trials x K)
#'     \item \code{trials}: list of length n_trials; each element is a list
#'           with \code{y_list}, a list of K numeric vectors (one per cohort)
#'     \item \code{previous_analyses}: list (initially empty)
#'   }
#' @export
simulateScenariosNormal <- function(
    n_subjects_list,
    mean_list,
    sd,
    scenario_numbers = seq_along(mean_list),
    n_trials         = 1e4
) {
  
  error_n_subjects_list  <-
    "Provide a list of vectors of positive integers for 'n_subjects_list'."
  error_mean_list        <-
    "Provide a list of numeric vectors for 'mean_list'."
  error_sd               <-
    "Provide a positive numeric or a list of numeric vectors for 'sd'."
  error_n_trials         <-
    "Provide a positive integer for the argument 'n_trials'."
  error_scenario_numbers <-
    "Provide a vector of positive integers for the argument 'scenario_numbers'."
  
  checkmate::assert_list(
    mean_list,
    types       = "numeric",
    any.missing = FALSE,
    .var.name   = error_mean_list
  )
  
  ## allow a single vector for n_subjects_list
  if (!is.list(n_subjects_list)) {
    n_subjects_list <- rep(list(n_subjects_list), length(mean_list))
  }
  
  checkmate::assert_list(
    n_subjects_list,
    types       = "numeric",
    any.missing = FALSE,
    .var.name   = error_n_subjects_list
  )
  
  checkmate::assert_true(
    all(vapply(
      n_subjects_list,
      checkmate::test_integerish,
      logical(1),
      lower       = 1,
      any.missing = FALSE
    )),
    .var.name = error_n_subjects_list
  )
  
  checkmate::assert_integerish(
    scenario_numbers,
    lower       = 1,
    any.missing = FALSE,
    .var.name   = error_scenario_numbers
  )
  
  checkmate::assert_true(
    length(scenario_numbers) == length(n_subjects_list),
    .var.name = "'scenario_numbers' and 'n_subjects_list' must have same length"
  )
  
  checkmate::assert_true(
    length(n_subjects_list) == length(mean_list),
    .var.name = "'n_subjects_list' and 'mean_list' must have same length"
  )
  
  n_cohorts <- length(mean_list[[1L]])
  
  checkmate::assert_true(
    n_cohorts >= 2L,
    .var.name = "Each scenario must have at least 2 cohorts"
  )
  
  cohort_lengths_mu <- vapply(mean_list, length, integer(1))
  checkmate::assert_true(
    all(cohort_lengths_mu == n_cohorts),
    .var.name = "All scenarios must have same number of cohorts in 'mean_list'"
  )
  
  cohort_lengths_ns <- vapply(n_subjects_list, length, integer(1))
  checkmate::assert_true(
    all(cohort_lengths_ns == n_cohorts),
    .var.name = "All scenarios must have same number of cohorts in 'n_subjects_list'"
  )
  
  if (is.list(sd)) {
    checkmate::assert_true(
      length(sd) == length(mean_list),
      .var.name = "Length of 'sd' list must equal length of 'mean_list'"
    )
    for (i in seq_along(sd)) {
      checkmate::assert_numeric(
        sd[[i]],
        any.missing = FALSE,
        lower       = 0,
        .var.name   = error_sd
      )
      checkmate::assert_true(
        length(sd[[i]]) %in% c(1L, n_cohorts),
        .var.name = "Each 'sd'[[i]] must have length 1 or K"
      )
    }
  } else {
    checkmate::assert_number(sd, lower = 0, finite = TRUE, .var.name = error_sd)
    ## turn into scenario-wise list for convenience
    sd <- rep(list(rep(sd, length.out = n_cohorts)), length(mean_list))
  }
  
  if ("n_trials" %in% ls(envir = .GlobalEnv) && missing(n_trials)) {
    n_trials <- get("n_trials", envir = .GlobalEnv)
  }
  
  checkmate::assert_count(
    n_trials,
    positive  = TRUE,
    .var.name = error_n_trials
  )
  
  scenario_list <- vector("list", length = length(scenario_numbers))
  
  for (s in seq_along(scenario_numbers)) {
    
    n_subj_vec <- as.integer(n_subjects_list[[s]])
    mu_vec     <- mean_list[[s]]
    sd_vec     <- if (length(sd[[s]]) == 1L) rep(sd[[s]], n_cohorts) else sd[[s]]
    
    ## n_subjects matrix: n_trials x K (same n per trial)
    n_subjects_mat <- matrix(
      rep(n_subj_vec, each = n_trials),
      nrow = n_trials,
      ncol = n_cohorts,
      byrow = FALSE
    )
    
    ## trials: list of length n_trials; each contains y_list (one vector per cohort)
    trials <- vector("list", length = n_trials)
    
    for (t in seq_len(n_trials)) {
      y_list <- vector("list", length = n_cohorts)
      for (k in seq_len(n_cohorts)) {
        n_k        <- n_subj_vec[k]
        y_list[[k]] <- stats::rnorm(n_k, mean = mu_vec[k], sd = sd_vec[k])
      }
      names(y_list) <- paste0("c_", seq_len(n_cohorts))
      trials[[t]] <- list(y_list = y_list)
    }
    
    scenario_list[[s]] <- list(
      scenario_number   = scenario_numbers[s],
      n_subjects        = n_subjects_mat,
      trials            = trials,
      previous_analyses = list(
        go_decisions   = matrix(1, nrow = n_trials, ncol = 1),   # all "go" initially
        post_quantiles = NULL
      )
    )
  }
  
  names(scenario_list) <- paste0("scenario_", scenario_numbers)
  class(scenario_list) <- "scenario_list_normal"
  
  return(scenario_list)
}

#' @title createTrial
#' @description This function creates an object of class `scenario_list_normal`
#' for a single trial outcome, which can subsequently be analyzed with other
#' functions of `bhmbasket`, e.g. \code{\link[bhmbasket]{performAnalysesNormal}}.
#'
#' @param n_subjects A vector of integers for the number of subjects in the trial outcome
#'   per cohort.
#' @param means A vector of numerics for the (true or observed) means in the trial outcome
#'   per cohort.
#' @param sd A positive numeric value for the common standard deviation.
#'
#' @return An object of class `scenario_list_normal` with the scenario data for a
#' single trial outcome.
#'
#' @details This function is a wrapper for \code{\link[bhmbasket]{simulateScenariosNormal}} with
#' \preformatted{
#' simulateScenariosNormal(
#'   n_subjects_list = list(n_subjects),
#'   mean_list       = list(means),
#'   sd              = sd,
#'   n_trials        = 1
#' )
#' }
#'
#' @seealso
#'   \code{\link[bhmbasket]{simulateScenariosNormal}}
#'   \code{\link[bhmbasket]{performAnalysesNormal}}
#'
#' @author Stephan Wojciekowski (adapted to normal endpoint)
#' @rdname createTrial
#' @examples
#'   trial_outcome <- createTrial(
#'     n_subjects = c(10, 20, 30),
#'     means      = c(0.5, 0.7, 0.9),
#'     sd         = 1
#'   )
#' @export
#' @md
createTrial <- function(
    n_subjects,
    means,
    sd
) {
  error_n_subjects <- "Providing a vector of integers for the argument 'n_subjects'"
  error_means      <- "Providing a vector of numerics for the argument 'means'"
  error_sd         <- "Providing a positive numeric value for the argument 'sd'"
  
  checkmate::assert_integerish(
    n_subjects,
    any.missing = FALSE,
    min.len     = 1,
    .var.name   = error_n_subjects
  )
  
  checkmate::assert_numeric(
    means,
    any.missing = FALSE,
    min.len     = 1,
    .var.name   = error_means
  )
  
  checkmate::assert_true(
    length(n_subjects) == length(means),
    .var.name = "n_subjects and means must have the same length"
  )
  
  checkmate::assert_number(
    sd,
    lower     = 0,
    finite    = TRUE,
    .var.name = error_sd
  )
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###
  
  utils::capture.output({
    trial <- simulateScenariosNormal(
      n_subjects_list = list(as.integer(n_subjects)),
      mean_list       = list(as.numeric(means)),
      sd              = sd,
      n_trials        = 1
    )
  })
  
  return(trial)
}

#' @title continueRecruitment
#' @md
#' @description This function continues the recruitment of subjects for a set of scenarios
#' based on the Go / NoGo decisions in the simulated trial outcomes of said scenarios.
#' @param n_subjects_add_list A list that contains for each scenario an integer vector for
#' the number of subjects per cohort to be additionally recruited.
#' @param decisions_list A list with decisions per scenario created with
#' `getGoDecisionsNormal()`
#' @param method_name A string for the method name of the analysis the decisions are based on.
#' Can be `NULL` if only one method has been used for analysis, Default: `NULL`
#' @return An object of class `scenario_list_normal` with the scenario data for each specified scenario.
#' @details
#' This function is intended to be used for analyses with the following workflow:\cr
#' `simulateScenariosNormal()` -> `performAnalysesNormal()` -> `getGoDecisionsNormal()` -> \cr
#' `continueRecruitment()` -> `performAnalysesNormal()` -> `getGoDecisionsNormal()` -> \cr
#' `continueRecruitment()` -> ...
#'
#' Note that `n_subjects_add_list` takes the additional number of subjects to be recruited,
#' not the overall number of subjects.
#' This way the workflow can be repeated as often as
#' required, which can be useful e.g. for interim analyses.
#' @examples
#' interim_scenarios <- simulateScenariosNormal(
#'   n_subjects_list = list(c(10, 20, 30)),
#'   mean_list       = list(c(0, 0, 0)),
#'   sd              = 1,
#'   n_trials        = 10
#' )
#'
#' interim_analyses <- performAnalysesNormal(
#'   scenario_list       = interim_scenarios,
#'   evidence_levels     = c(0.025, 0.5, 0.975),
#'   n_mcmc_iterations   = 100
#' )
#'
#' interim_gos <- getGoDecisionsNormal(
#'   analyses_list   = interim_analyses,
#'   cohort_names    = c("mu_1", "mu_2", "mu_3"),
#'   evidence_levels = c(0.5, 0.8, 0.5),
#'   boundary_rules  = quote(c(x[1] > 0.8, x[2] > 0.6, x[3] > 0.7))
#' )
#'
#' scenarios_list2 <- continueRecruitment(
#'   n_subjects_add_list = list(c(30, 20, 10)),
#'   decisions_list      = interim_gos,
#'   method_name         = "normal"
#' )
#' @seealso
#'  \code{\link{simulateScenariosNormal}}
#'  \code{\link{performAnalysesNormal}}
#'  \code{\link{getGoDecisionsNormal}}
#' @rdname continueRecruitment
#' @author Stephan Wojciekowski (adapted for normal endpoints)
#' @export
continueRecruitment <- function(
    n_subjects_add_list,
    decisions_list,
    method_name = NULL
) {
  
  error_n_subjects_add_list <-
    "Providing a list of vectors of non-negative integers for the argument 'n_subjects_add_list'"
  error_decisions_list <-
    "Providing an object of class decision_list for the argument 'decisions_list'"
  error_method_name <- simpleError(paste(
    "Please provide a string naming an analysis method for the argument 'method_name'.",
    "Must be 'normal' in the normal-endpoint setting."
  ))
  
  checkmate::assert_true(!missing(n_subjects_add_list), .var.name = error_n_subjects_add_list)
  checkmate::assert_true(!missing(decisions_list),      .var.name = error_decisions_list)
  
  checkmate::assert_class(decisions_list, "decision_list", .var.name = error_decisions_list)
  
  ## determine method_name if not given
  if (is.null(method_name)) {
    
    n_methods <- length(decisions_list$scenario_1$decisions_list)
    
    if (n_methods > 1) {
      stop(error_method_name)
    } else {
      method_name <- names(decisions_list$scenario_1$decisions_list)
    }
    
  } else {
    
    method_name <- tryCatch({
      match.arg(
        method_name,
        choices    = c("normal"),
        several.ok = FALSE
      )
    }, error = function(e) e)
    
    if (inherits(method_name, "error")) stop(error_method_name)
  }
  
  ## ensure list structure for n_subjects_add_list
  if (!is.list(n_subjects_add_list)) {
    n_subjects_add_list <- rep(list(n_subjects_add_list), length(decisions_list))
  }
  
  checkmate::assert_list(
    n_subjects_add_list,
    types       = c("integer", "numeric"),
    any.missing = FALSE,
    .var.name   = error_n_subjects_add_list
  )
  
  checkmate::assert_list(
    n_subjects_add_list,
    len        = length(decisions_list),
    any.missing = FALSE,
    .var.name   = "The lengths of 'n_subjects_add_list' and 'decisions_list' must be equal"
  )
  
  checkmate::assert_true(
    all(vapply(
      n_subjects_add_list,
      checkmate::test_integerish,
      logical(1),
      lower       = 0,
      any.missing = FALSE
    )),
    .var.name = error_n_subjects_add_list
  )
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###
  
  scenario_numbers <- as.numeric(sub("scenario_", "", names(decisions_list)))
  
  scenario_list <- vector(mode = "list", length = length(decisions_list))
  names(scenario_list) <- paste0("scenario_", scenario_numbers)
  
  for (s in seq_along(scenario_list)) {
    
    analysis_params <- decisions_list[[s]]$analysis_data$analysis_parameters
    
    if (!(method_name %in% analysis_params$method_names)) {
      stop(simpleError("Selected method_name not analyzed"))
    }
    
    n_subjects_add <- as.integer(n_subjects_add_list[[s]])
    
    scenario_data   <- decisions_list[[s]]$scenario_data
    n_subjects      <- scenario_data$n_subjects     # matrix: trials x cohorts
    n_trials        <- scenario_data$n_trials
    means           <- scenario_data$means         # vector length K
    sd              <- scenario_data$sd            # scalar (or vector length K)
    
    K <- ncol(n_subjects)
    
    checkmate::assert_true(
      length(n_subjects_add) == K,
      .var.name = "The length of 'n_subjects_add' must match the number of cohorts"
    )
    
    ## ensure sd is vector of length K
    if (length(sd) == 1L) {
      sd_vec <- rep(sd, K)
    } else {
      sd_vec <- sd
    }
    
    ## decisions
    go_decisions <- decisions_list[[s]]$decisions_list[[method_name]]
    previous_gos <- go_decisions
    
    if ("overall" %in% colnames(go_decisions)) {
      overall_gos  <- go_decisions[, "overall"] > 0
      go_decisions <- go_decisions[, colnames(go_decisions) != "overall", drop = FALSE]
    } else {
      overall_gos <- rep(TRUE, nrow(go_decisions))
    }
    
    ## we expect one decision column per cohort: decision_1, decision_2, ...
    if (!all(seq_len(K) %in% as.numeric(sub("decision_", "", colnames(go_decisions))))) {
      stop(simpleError(
        "There must be a decision for each cohort in the 'decisions_list'"
      ))
    }
    
    go_decisions <- go_decisions > 0
    
    ## copy original structures
    n_subjects_new <- n_subjects
    trials_new     <- scenario_data$trials
    
    ## simulate and append additional normal outcomes
    for (t in seq_len(n_trials)) {
      if (!overall_gos[t]) next
      
      for (k in seq_len(K)) {
        if (!go_decisions[t, k]) next
        n_add <- n_subjects_add[k]
        if (n_add <= 0) next
        
        y_add <- stats::rnorm(n_add, mean = means[k], sd = sd_vec[k])
        
        trials_new[[t]]$y_list[[k]] <-
          c(trials_new[[t]]$y_list[[k]], y_add)
        
        n_subjects_new[t, k] <- n_subjects_new[t, k] + n_add
      }
    }
    
    scenario_list[[s]] <- list(
      n_subjects        = n_subjects_new,
      trials            = trials_new,
      means             = means,
      sd                = sd,
      previous_analyses = list(
        go_decisions   = previous_gos,
        post_quantiles = decisions_list[[s]]$analysis_data$quantiles_list
      ),
      n_trials          = n_trials
    )
    
    scenario_list[[s]]$scenario_number <- scenario_data$scenario_number
  }
  
  class(scenario_list) <- "scenario_list_normal"
  
  return(scenario_list)
}

getNSubjectsNormal <- function(
    recruitment_per_month,
    start_date,
    analysis_dates,
    date_format = "%m/%d/%Y"
) {
  recruitment_per_day <- recruitment_per_month * (12 / 365)
  
  start_date     <- as.Date(start_date, format = date_format)
  analysis_dates <- as.Date(analysis_dates, format = date_format)
  
  n_subjects_matrix <- floor((analysis_dates - start_date) %o% recruitment_per_day)
  
  rownames(n_subjects_matrix) <- format(analysis_dates, format = date_format)
  colnames(n_subjects_matrix) <- paste0("cohort_", seq_len(ncol(n_subjects_matrix)))
  
  return(n_subjects_matrix)
}

getRecruitmentNormal <- function (
    
  n_subjects_required,
  recruitment_per_month,
  start_date,
  
  date_format = "%m/%d/%Y"
  
) {
  
  
  checkmate::assert_numeric(
    
    n_subjects_required, lower = 0, any.missing = FALSE,
    .var.name = "Providing a matrix of non-negative integers for the argument 'n_subjects_required'"
  )
  
  checkmate::assert_true(
    
    checkmate::test_integerish(n_subjects_required, lower = 0),
    .var.name = "Providing a matrix of non-negative integers for the argument 'n_subjects_required'"
  )
  
  checkmate::assert_numeric(
    
    recruitment_per_month, lower = 0, any.missing = FALSE,
    .var.name = "Providing a vector of non-negative numerics for the argument 'recruitment_per_month'")
  
  checkmate::assert_string(
    
    start_date, pattern = ".+",
    .var.name = "Please provide a string in the format 'date_format' of for the argument 'start_date'")
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###
  
  hist_index <- recruitment_per_month == 0
  
  recruitment_per_day <- recruitment_per_month[!hist_index] * (12 / 365)
  
  start_date <- as.Date(start_date, format = date_format)
  
  n_subjects_required <- convertVector2Matrix(n_subjects_required)
  
  checkmate::assert_true(
    length(recruitment_per_month) == ncol(n_subjects_required))
  
  days_required <- apply(convertVector2Matrix(n_subjects_required[, !hist_index]),
                         1, function (n_subj) {
                           max(ceiling(n_subj * recruitment_per_day^-1))
                         })
  
  n_subjects_matrix_0 <- getNSubjectsNormal(
    recruitment_per_month = recruitment_per_month[!hist_index],
    start_date            = start_date,
    analysis_dates        = start_date + days_required,
    date_format           = date_format)
  
  n_subjects_matrix <- matrix(NA,
                              ncol = ncol(n_subjects_required),
                              nrow = nrow(n_subjects_required))
  
  n_subjects_matrix[, !hist_index] <- n_subjects_matrix_0
  n_subjects_matrix[, hist_index]  <- n_subjects_required[, hist_index]
  
  rownames(n_subjects_matrix) <- rownames(n_subjects_matrix_0)
  colnames(n_subjects_matrix) <- paste0("cohort_", seq_len(ncol(n_subjects_required)))
  
  return (n_subjects_matrix)
  
}

#' @title saveScenariosNormal
#' @md
#' @description Saves the normal-endpoint scenario data in a newly created or
#'   existing directory.
#' @param scenario_list An object of class `scenario_list_normal`,
#'   e.g. created with `simulateScenariosNormal()`.
#' @param save_path A string providing the path for the directory in which the
#'   scenario files should be created, Default: [base::tempdir()].
#' @return A named list of length 2 with the scenario numbers and the `save_path`.
#' @seealso
#'   [simulateScenariosNormal()],
#'   [loadScenariosNormal()],
#'   [base::tempdir()]
#' @export
saveScenariosNormal <- function(
    scenario_list,
    save_path = tempdir()
) {
  checkmate::assert(
    checkmate::check_class(scenario_list, "scenario_list_normal"),
    checkmate::check_character(save_path, len = 1),
    combine   = "and",
    .var.name = "Please provide an object of class 'scenario_list_normal' for the argument 'scenario_list'"
  )
  
  if (!dir.exists(save_path)) {
    dir.create(save_path, recursive = TRUE)
  }
  
  scenario_numbers <- vapply(
    scenario_list,
    function(x) x$scenario_number,
    FUN.VALUE = integer(1L)
  )
  
  for (s in seq_along(scenario_list)) {
    saveRDS(
      scenario_list[[s]],
      file = file.path(save_path, paste0("scenario_data_", scenario_numbers[s], ".rds"))
    )
  }
  
  list(
    scenario_numbers = scenario_numbers,
    path             = save_path
  )
}

#' @title loadScenariosNormal
#' @md
#' @description
#' Load normal-endpoint scenarios saved with `saveScenariosNormal()`.
#'
#' @param scenario_numbers A vector of positive integers naming the scenarios to be loaded.
#' @param load_path A string for the directory where the scenarios are stored,
#'   Default: [base::tempdir()].
#'
#' @return
#' An object of class `scenario_list_normal`.
#'
#' @seealso
#'  \code{\link[bhmbasket]{simulateScenariosNormal}}
#'  \code{\link[bhmbasket]{saveScenariosNormal}}
#'  \code{\link[base]{tempdir}}
#'
#' @examples
#' \dontrun{
#'   scenarios_list <- simulateScenariosNormal(
#'     n_subjects_list = list(c(50, 50)),
#'     mean_list       = list(c(0, 1)),
#'     sd              = 1,
#'     n_trials        = 10
#'   )
#'
#'   save_info      <- saveScenariosNormal(scenarios_list)
#'   scenarios_list <- loadScenariosNormal(
#'     scenario_numbers = save_info$scenario_numbers,
#'     load_path        = save_info$path
#'   )
#' }
#' @export
loadScenariosNormal <- function(
    scenario_numbers,
    load_path = tempdir()
) {
  checkmate::assert_integerish(
    scenario_numbers,
    lower      = 1,
    any.missing = FALSE,
    .var.name  = "Providing a vector of positive integers for the argument 'scenario_numbers'"
  )
  
  checkmate::assert_string(
    load_path,
    .var.name = "Providing a string for the argument 'load_path'"
  )
  
  files <- file.path(load_path, paste0("scenario_data_", scenario_numbers, ".rds"))
  scenario_list <- lapply(files, readRDS)
  
  names(scenario_list) <- paste0("scenario_", scenario_numbers)
  class(scenario_list) <- "scenario_list_normal"
  
  return(scenario_list)
}

#' @export
print.scenario_list_normal <- function(x, ...) {
  
  n_scenarios    <- length(x)
  scenario_names <- names(x)
  
  # true means per cohort
  true_means   <- lapply(x, function(s) s$means)
  n_cohorts    <- length(true_means[[1L]])
  cohort_names <- paste0("c_", seq_len(n_cohorts))
  
  # average sample size per cohort over trials
  n_subjects_avg <- lapply(x, function(s) {
    colMeans(as.matrix(s$n_subjects))
  })
  
  # trial counts
  n_trial_realizations  <- x[[1L]]$n_trials
  n_unique_realizations <- nrow(getUniqueTrialsNormal(x))
  
  cat("scenario_list_normal of ", n_scenarios, " scenario",
      ifelse(n_scenarios == 1, "", "s"),
      " with ", n_cohorts, " cohort", ifelse(n_cohorts == 1, "", "s"),
      "\n\n", sep = "")
  
  for (n in seq_along(scenario_names)) {
    
    df_out <- rbind(
      "    - true means:"               = true_means[[n]],
      "    - average number of subjects:" = n_subjects_avg[[n]]
    )
    
    colnames(df_out) <- cohort_names
    
    cat("  -", scenario_names[n], "\n")
    print(df_out)
    cat("\n")
  }
  
  cat("  -", n_trial_realizations,  " trial realizations per scenario\n")
  cat("  -", n_unique_realizations, " unique trial realizations overall\n")
}
