getGoProbabilities <- function (
  
  go_decisions_list,
  nogo_decisions_list = NULL
  
) {
  
  checkmate::assertClass(go_decisions_list, "decision_list", .var.name = "go_decisions_list")
  
  checkmate::assertClass(nogo_decisions_list, "decision_list", null.ok = TRUE,)
  
  # Validate that both decision lists have the same dimensions if nogo_decisions_list is not NULL
  if (!is.null(nogo_decisions_list)) {
    checkmate::assertTRUE(
      identical(
        dim(go_decisions_list[[1]]$decisions_list[[1]]),
        dim(nogo_decisions_list[[1]]$decisions_list[[1]])
      ),
      .var.name = "decision_list dimensions"
    )
  }
  
  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
  
  go_probs_per_scenario <- vector(mode = "list",
                                  length = length(go_decisions_list))
  names(go_probs_per_scenario) <- names(go_decisions_list)
  
  for (s in seq_along(go_probs_per_scenario)) {
    
    method_names <- names(go_decisions_list[[s]]$decisions_list)
    
    go_probs_per_method_list <- vector(mode = "list",
                                       length = length(method_names))
    names(go_probs_per_method_list) <- method_names
    
    for (n in seq_along(method_names)) {
      
      go_decisions     <- go_decisions_list[[s]]$decisions_list[[n]]
      decisions_matrix <- t(as.matrix(colMeans(go_decisions)))
      row.names(decisions_matrix) <- "Go"
      
      if (!is.null(nogo_decisions_list)) {
        
        nogo_decisions <- nogo_decisions_list[[s]]$decisions_list[[n]]
        nogo_probs     <- t(as.matrix(colMeans(nogo_decisions)))
        consider_probs <- round(1 - nogo_probs - decisions_matrix, 9)
        
        # calculate consider decision probabilities directly:
        # consider_decisions <- sapply(2:5, function (i) {
        #   !apply(cbind(nogo_decisions[, i], go_decisions[, i]), 1, any)
        # })
        # consider_decisions <- cbind(apply(consider_decisions, 1, any) &
        #                               !go_decisions[, 1],
        #                             consider_decisions)
        # consider_probs     <- t(as.matrix(colMeans(consider_decisions)))
        
        if (!isTRUE(all.equal(sum(go_decisions * nogo_decisions), 0)))
          stop (paste("There are cohorts for which both go and nogo decisions",
                      "are TRUE. Please revise your decision rules."))
        
        decisions_matrix <- rbind(decisions_matrix, consider_probs, nogo_probs)
        row.names(decisions_matrix) <- c("Go", "Consider", "NoGo")
        
      }
      
      go_probs_per_method_list[[n]] <- decisions_matrix
      
    }
    
    go_probs_per_scenario[[s]] <- go_probs_per_method_list
    
  }
  
  go_probs_per_method <- listPerMethod(go_probs_per_scenario)
  
  return (go_probs_per_method)
  
}
