## ------------------------------------------------------------------
## Helper: compute overall Go probability for (n, p_true, gamma)
## using the existing bhmbasket workflow.
## ------------------------------------------------------------------

go_prob_overall <- function(n,
                            p_true,
                            p_beta,
                            gamma,
                            n_trials = 1000,
                            method_name = "pooled") {
  # 1) Simulate n_trials basket trials with 1 cohort
  scen <- simulateScenarios(
    n_subjects_list     = list(c(n)),          # 1 cohort with n patients
    response_rates_list = list(c(p_true)),     # true response rate
    n_trials            = n_trials
  )
  
  # 2) Analyse with performAnalyses (pooled => analytic Beta posterior)
  analyses <- performAnalyses(
    scenario_list      = scen,
    target_rates       = c(p_beta),           # clinical boundary encoded as "target rate"
    method_names       = method_name,
    n_mcmc_iterations  = 100,                 # ignored for "pooled", but must be > 0
    verbose            = FALSE
  )
  
  # 3) Decision rule: P(p > p_beta | data) > gamma
  #    -> implemented as q_{1-gamma} > p_beta  via boundary_rules
  decisions <- getGoDecisions(
    analyses_list   = analyses,
    cohort_names    = "p_1",
    evidence_levels = gamma,                  # γ
    boundary_rules  = quote(c(x[1] > p_beta)) # p_beta from calling environment
  )
  
  # 4) Convert decisions to Go probabilities
  go_probs_list <- getGoProbabilities(decisions)
  # go_probs_list[[method_name]][["scenario_1"]] is a 1×K matrix (row "Go")
  go_mat <- go_probs_list[[method_name]][["scenario_1"]]
  
  # Column "overall" = P(overall Go)
  go_mat["Go", "overall"]
}


## ------------------------------------------------------------------
## Grid search: find (n, gamma) that satisfy type I & power constraints
## ------------------------------------------------------------------

# Design settings
p0          <- 0.30    # null true response rate
p1          <- 0.50    # alternative true response rate
p_beta      <- 0.50    # clinical boundary
alpha_max   <- 0.10    # allowed type I error
power_min   <- 0.80    # required power
n_trials_oc <- 1000    # number of simulated trials per (n, gamma) scenario

# Search grid:
n_grid     <- c(20, 30, 40, 50, 60)          # candidate sample sizes
gamma_grid <- seq(0.7, 0.95, by = 0.05)      # candidate evidence levels

oc_results <- expand.grid(
  n     = n_grid,
  gamma = gamma_grid
)

oc_results$alpha_hat <- NA_real_
oc_results$power_hat <- NA_real_

set.seed(2026)  # for reproducibility of the simulation

for (i in seq_len(nrow(oc_results))) {
  n_i     <- oc_results$n[i]
  gamma_i <- oc_results$gamma[i]
  
  # Type I error under p0
  oc_results$alpha_hat[i] <- go_prob_overall(
    n        = n_i,
    p_true   = p0,
    p_beta   = p_beta,
    gamma    = gamma_i,
    n_trials = n_trials_oc,
    method_name = "pooled"
  )
  
  # Power under p1
  oc_results$power_hat[i] <- go_prob_overall(
    n        = n_i,
    p_true   = p1,
    p_beta   = p_beta,
    gamma    = gamma_i,
    n_trials = n_trials_oc,
    method_name = "pooled"
  )
}

# Mark designs that satisfy the constraints
oc_results$feasible <- with(
  oc_results,
  alpha_hat <= alpha_max & power_hat >= power_min
)

oc_results


## ------------------------------------------------------------------
## Select minimal n that satisfies the design constraints
## ------------------------------------------------------------------

feasible_designs <- subset(oc_results, feasible)

if (nrow(feasible_designs) == 0) {
  message("No (n, gamma) combination satisfies the constraints with this grid.")
} else {
  # Sort by n, then by how close power/alpha are to targets (optional)
  feasible_designs <- feasible_designs[order(feasible_designs$n, -feasible_designs$power_hat), ]
  
  best_design <- feasible_designs[1, ]
  
  print(best_design)
  # You can phrase this in your report as:
  # "With n = best_design$n and gamma = best_design$gamma, we obtain
  #  estimated type I error alpha_hat and power power_hat under the chosen
  #  null/alternative, and this is the smallest n that meets our criteria."
}
