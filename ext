applicablePreviousTrials <- function(

  scenario_list,
  method_names,
  quantiles,
  n_cohorts,
  
  calc_differences

) {

  ## analyze only unique trials that have not been previously analyzed,
  ## i.e. trials that were updated with continueRecruitment(),
  ## i.e. trials that have an overall go decision from a previous decision rule
  ## i.e. trials that have quantiles stored for each cohort that is to be analysed
  applicable_previous_trials <-
    ## check that in each scenario the same analysis methods were analyzed previously
    all(sapply(seq_along(scenario_list), function (i) {
      isTRUE(all.equal(names(scenario_list[[i]]$previous_analyses$post_quantiles),
                       names(scenario_list[[1]]$previous_analyses$post_quantiles)))
    })) &
    ## check that the current analysis method names match the method names of the previous analyses
    isTRUE(all.equal(names(scenario_list[[1]]$previous_analyses$post_quantiles), method_names)) &
    ## check that the stored quantiles are the same across all scenarios
    all(sapply(seq_along(scenario_list), function (i) {
      isTRUE(all.equal(rownames(scenario_list[[i]]$previous_analyses$post_quantiles[[1]][[1]]),
                       rownames(scenario_list[[1]]$previous_analyses$post_quantiles[[1]][[1]])))
    })) &
    ## check that the new quantiles are within the stored quantiles
    all(paste0(as.character(quantiles * 100), "%") %in%
          rownames(scenario_list[[1]]$previous_analyses$post_quantiles[[1]][[1]])) &
    ## check that there are stored quantiles for each cohort that is to be analysed
    all(paste0("p_", seq_len(n_cohorts)) %in%
          colnames(scenario_list[[1]]$previous_analyses$post_quantiles[[1]][[1]]))

  ## check that all differences have been previously calculated
  if (!is.null(calc_differences)) {

    applicable_previous_trials <- applicable_previous_trials &
      all(apply(calc_differences, 1, function (x) {
        paste0("p_diff_", paste0(as.character(x), collapse = ""))
      }) %in% colnames(scenario_list[[1]]$previous_analyses$post_quantiles[[1]][[1]]))

  }

  return (applicable_previous_trials)

}

calcDiffsMCMC <- function (

  posterior_samples,
  calc_differences

) {

  org_names <- colnames(posterior_samples)

  diffs <- apply(calc_differences, 1, function (x) {

    matrix(posterior_samples[, grepl(x[1], org_names) & grepl("p", org_names)] -
             posterior_samples[, grepl(x[2], org_names) & grepl("p", org_names)],
           ncol = 1)

  })

  diff_names <- apply(calc_differences, 1, function (x) {

    paste0("p_diff_", paste0(as.character(x), collapse = ""))

  })

  colnames(diffs) <- diff_names

  posterior_samples <- cbind(posterior_samples, diffs)

  return (posterior_samples)

}

getModelFile <- function (method_name, custom_methods=NULL) {

  if (method_name == "berry") {

    model_file <- "berry.txt"

  } else if (method_name == "berry_mix") {

    model_file <- "berry_mix.txt"

  } else if (method_name == "exnex") {

    model_file <- "exnex.txt"

  } else if (method_name == "exnex_adj") {

    model_file <- "exnex_adj.txt"

  } else if (method_name == "berry_mix") {

    model_file <- "berry_mix.txt"

  } else {

    stop ("method_name must be one of berry, berry_mix, exnex, exnex_adj")

  }

  model_file <- system.file(package = "bhmbasket", "jags_models", model_file, mustWork = TRUE)

  return (model_file)

}

getPosteriors <- function (

  j_parameters,
  j_model_file,
  j_data,

  n_mcmc_iterations

) {

  ## Adaption and burn-in not included
  posterior_samples <- performJags(
    data               = j_data,
    parameters_to_save = j_parameters,
    model_file         = j_model_file,
    n_iter             = n_mcmc_iterations)

  ## replace squarebrackets provided by rjags with workable characters
  colnames(posterior_samples) <- gsub("\\[", "_", colnames(posterior_samples))
  colnames(posterior_samples) <- gsub("\\]", "", colnames(posterior_samples))

  weights_indices <- grepl("exch", colnames(posterior_samples))
  if (any(weights_indices)) {

    superfluous_weights <- !grepl(",1", colnames(posterior_samples))

    colnames(posterior_samples)[weights_indices] <-
      paste0("w_", seq_along(j_data$n))

    posterior_samples <- posterior_samples[, !(weights_indices & superfluous_weights)]

  }

  return (posterior_samples)

}

getPostQuantiles <- function (## The method to be applied to the likelihood and the quantiles of the posterior
  method_name,
  quantiles,
  
  ## Scenario data
  scenario_data,
  
  ## Differences between cohorts
  calc_differences  = NULL,
  
  ## JAGS parameters
  j_parameters,
  j_model_file,
  j_data,
  
  ## MCMC Parameters
  n_mcmc_iterations = 1e4,
  
  ## Where to save one of the posterior response rates approximations provided by JAGS
  save_path         = NULL,
  save_trial        = NULL) {
  if (is.null(dim(scenario_data$n_responders))) {
    scenario_data$n_responders <-
      t(convertVector2Matrix(scenario_data$n_responders))
    scenario_data$n_subjects   <-
      t(convertVector2Matrix(scenario_data$n_subjects))
    
  }
  
  n_analyses <- nrow(scenario_data$n_responders)
  
  ## Create random index for saving one of the posterior response rates
  if (is.null(save_trial) && !is.null(save_path)) {
    # set.seed(seed)
    save_trial <- sample(seq_len(n_analyses), size = 1)
  }
  
 
  posterior_quantiles_list <- suppressMessages(
    foreach::foreach(
      k = seq_len(n_analyses),
      .combine  = c,
      .verbose  = FALSE,
      .options.future = list(seed = TRUE)
    ) %dofuture% {
      lapply(k, function (j) {
        getPostQuantilesOfTrial(
          n_responders      = as.numeric(scenario_data$n_responders[j,]),
          n_subjects        = as.numeric(scenario_data$n_subjects[j,]),
          j_data            = j_data,
          j_parameters      = j_parameters,
          j_model_file      = j_model_file,
          method_name       = method_name,
          quantiles         = quantiles,
          calc_differences  = calc_differences,
          n_mcmc_iterations = n_mcmc_iterations,
          save_path         = save_path,
          save_trial        = save_trial
        )
        
      })

      
    }
  )
  
  
return ( posterior_quantiles_list)
}




getPostQuantilesOfTrial <- function (

  n_responders,
  n_subjects,

  j_data,
  j_parameters,
  j_model_file,
  method_name,
  quantiles,
  calc_differences,
  n_mcmc_iterations,

  save_path,
  save_trial

) {

  j_data$r <- n_responders
  j_data$n <- n_subjects

  if (method_name == "stratified") {

    posterior_quantiles <- getPostQuantilesStratified(
      j_data            = j_data,
      quantiles         = quantiles,
      calc_differences  = calc_differences,
      n_mcmc_iterations = n_mcmc_iterations)
    


  } else if (method_name == "pooled") {

    posterior_quantiles <- getPostQuantilesPooled(
      j_data           = j_data,
      quantiles        = quantiles,
      calc_differences = calc_differences)

  } else if (method_name == "MEM") {

    posterior_quantiles <- getPostQuantilesMEM(
      j_data           = j_data,
      quantiles        = quantiles,
      calc_differences = calc_differences)

  } else {

    ## Get posterior response rates per indication
    posterior_samples <- getPosteriors(
      j_parameters      = j_parameters,
      j_model_file      = j_model_file,
      j_data            = j_data,
      n_mcmc_iterations = n_mcmc_iterations)

    ## Calculate differences between response rates of cohorts
    if (!is.null(calc_differences)) {

      posterior_samples <- calcDiffsMCMC(
        posterior_samples = posterior_samples,
        calc_differences        = calc_differences)

    }

    ## Save posterior response rates per indication for one randomly selected simulation,
    ## due to time and storage space constraints only one simulation
    if (!is.null(save_path)) {
      if (k == save_trial) {
        saveRDS(posterior_samples,
                file = file.path(save_path, paste0("posterior_samples_",
                                                   k, "_", method_name, "_rds")))
      }
    }

    ## Calculate the required quantiles for the decision rules
    posterior_quantiles <- posteriors2Quantiles(
      quantiles  = quantiles,
      posteriors = posterior_samples)

  }


  return (posterior_quantiles)
}

getPostQuantilesMEM <- function(

  j_data,
  quantiles,
  calc_differences

) {


  model_MEM <- mem_mcmc_samples(responses = j_data$r,
                      size = j_data$n, shape1=j_data$shape1, shape2= j_data$shape2)


  posterior_quantiles <- apply(model_MEM[[1]], 2, function(x) quantile(x, quantiles))


  colnames(posterior_quantiles) <- paste0("p_", seq_along(j_data$r))
  rownames(posterior_quantiles) <- paste0(quantiles * 100, "%")

  posterior_mean      <- colMeans(model_MEM[[1]])
  posterior_sd        <- apply(model_MEM[[1]], 2, sd)
  posterior_quantiles <- rbind(posterior_quantiles,
                               Mean = posterior_mean,
                               SD   = posterior_sd)

  if (!is.null(calc_differences)) {

    diff_quantiles <- apply(calc_differences, 1, function (x) {

      matrix(rep(0, nrow(posterior_quantiles)), ncol = 1)

    })

    diff_names <- apply(calc_differences, 1, function (x) {

      paste0("p_diff_", paste0(as.character(x), collapse = ""))

    })

    colnames(diff_quantiles) <- diff_names

    posterior_quantiles <- cbind(posterior_quantiles, diff_quantiles)

  }
mem<-list(posterior_quantiles=posterior_quantiles, Psi= model_MEM[[2]], Encoder=model_MEM[[3]], Prior = model_MEM[[4]])
  
return (mem)

}

getPostQuantilesPooled <- function(

  j_data,
  quantiles,
  calc_differences

) {

  shape_1 <- j_data$a + sum(j_data$r)
  shape_2 <- j_data$b + sum(j_data$n) - sum(j_data$r)

  posterior_quantiles <- stats::qbeta(quantiles, shape1 = shape_1, shape2 = shape_2)

  posterior_quantiles <- matrix(posterior_quantiles,
                                ncol = length(j_data$r), nrow = length(quantiles))

  colnames(posterior_quantiles) <- paste0("p_", seq_along(j_data$r))
  rownames(posterior_quantiles) <- paste0(quantiles * 100, "%")

  posterior_mean      <- shape_1 / (shape_1 + shape_2)
  posterior_sd        <- ((shape_1 * shape_2) / ((shape_1 + shape_2)^2 * (shape_1 + shape_2 + 1)))^0.5
  posterior_quantiles <- rbind(posterior_quantiles,
                               Mean = posterior_mean,
                               SD   = posterior_sd)

  if (!is.null(calc_differences)) {

    diff_quantiles <- apply(calc_differences, 1, function (x) {

      matrix(rep(0, nrow(posterior_quantiles)), ncol = 1)

    })

    diff_names <- apply(calc_differences, 1, function (x) {

      paste0("p_diff_", paste0(as.character(x), collapse = ""))

    })

    colnames(diff_quantiles) <- diff_names

    posterior_quantiles <- cbind(posterior_quantiles, diff_quantiles)

  }

  return (posterior_quantiles)

}

getPostQuantilesStratified <- function(

  j_data,
  quantiles,
  calc_differences,
  n_mcmc_iterations

) {

  shape_1 <- j_data$a_j + j_data$r
  shape_2 <- j_data$b_j + j_data$n - j_data$r
print(shape_1)
print(shape_2)
  posterior_quantiles <- t(sapply(quantiles, function (x)
    stats::qbeta(x, shape1 = shape_1, shape2 = shape_2)))

  if (nrow(posterior_quantiles) == 1) {

    posterior_quantiles <- t(posterior_quantiles)

  }

  colnames(posterior_quantiles) <- paste0("p_", seq_along(j_data$a_j))
  rownames(posterior_quantiles) <- paste0(quantiles * 100, "%")

  posterior_mean      <- shape_1 / (shape_1 + shape_2)
  posterior_sd        <- ((shape_1 * shape_2) / ((shape_1 + shape_2)^2 * (shape_1 + shape_2 + 1)))^0.5
  posterior_quantiles <- rbind(posterior_quantiles,
                               Mean = posterior_mean,
                               SD   = posterior_sd)

  if (!is.null(calc_differences)) {

    diff_quantiles <- apply(calc_differences, 1, function (x) {

      matrix(qbetaDiff(
        quantiles  = quantiles,
        x_1_shape1 = shape_1[x[1]],
        x_1_shape2 = shape_2[x[1]],
        x_2_shape1 = shape_1[x[2]],
        x_2_shape2 = shape_2[x[2]],
        n_mcmc     = n_mcmc_iterations), ncol = 1)

    })

    diff_names <- apply(calc_differences, 1, function (x) {

      paste0("p_diff_", paste0(as.character(x), collapse = ""))

    })

    colnames(diff_quantiles) <- diff_names

    posterior_quantiles <- cbind(posterior_quantiles, diff_quantiles)

  }

 # return (list((sapply(1:length(shape_1), function(i) rbeta(13334, shape_1[i], shape_2[i]))), posterior_quantiles))
return(posterior_quantiles)
}

getUniqueRows <- function (

  matrix

) {

  n_rows      <- nrow(matrix)
  n_cols      <- ncol(matrix)

  unique_rows <- stats::aggregate(id ~ .,
                                  data = cbind(id = seq_along(n_rows), matrix),
                                  FUN  = length)

  return (unique_rows[, seq_len(n_cols)])

}

getUniqueTrials <- function (

  scenario_list

) {

  all_scenarios_n_responders <- do.call(rbind, lapply(scenario_list, function (x) x$n_responders))
  all_scenarios_n_subjects   <- do.call(rbind, lapply(scenario_list, function (x) x$n_subjects))
  all_scenarios_overall_gos  <- do.call(rbind, lapply(scenario_list, function (x)
    x$previous_analyses$go_decisions))[, 1]

  return (getUniqueRows(cbind(all_scenarios_n_responders,
                              all_scenarios_n_subjects,
                              go_flag = all_scenarios_overall_gos)))

}

is.analysis_list <- function (x) {

  if (missing(x)) stop ("Please provide an object for the argument 'x'")

  inherits(x, "analysis_list")

}

#' @title loadAnalyses
#' @md
#' @description This function loads an analysis performed with
#' \code{\link[bhmbasket]{performAnalyses}}
#' @param load_path A string providing a path where the scenarios are being stored,
#' Default: \code{\link[base]{tempfile}}
#' @param scenario_numbers A (vector of) positive integer(s) for the scenario number(s)
#' @param analysis_numbers A (vector of) positive integer(s) for the analysis number(s),
#' Default: `rep(1, length(scenario_numbers))`
#' @return Returns an object of class `analysis_list`
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{saveAnalyses}}
#'  \code{\link[base]{tempfile}}
#' @rdname loadAnalyses
#' @examples
#'   trial_data <- createTrial(
#'     n_subjects   = c(10, 20, 30),
#'     n_responders = c(1, 2, 3))
#'
#'   analysis_list <- performAnalyses(
#'     scenario_list      = trial_data,
#'     target_rates       = rep(0.5, 3),
#'     n_mcmc_iterations  = 100)
#'
#'   save_info     <- saveAnalyses(analysis_list)
#'   analysis_list <- loadAnalyses(scenario_numbers = save_info$scenario_numbers,
#'                                 analysis_numbers = save_info$analysis_numbers,
#'                                 load_path        = save_info$path)
#' @author Stephan Wojciekowski
#' @export
loadAnalyses <- function (

  scenario_numbers,
  analysis_numbers = rep(1, length(scenario_numbers)),
  load_path        = tempdir()

) {

  error_scenario_numbers <- simpleError(
    "Please provide a vector of positive integers for the argument 'scenario_numbers'")
  error_analysis_numbers <- simpleError(
    "Please provide a vector of positive integers for the argument 'analysis_numbers'")
  error_load_path        <- simpleError(
    "Please provide a string containing a path for the argument 'load_path'")

  if (missing(scenario_numbers)) stop (error_scenario_numbers)

  if (!is.character(load_path) || length(load_path) > 1) stop (error_load_path)

  if (!identical(length(scenario_numbers), length(analysis_numbers))) {
    stop (simpleError("'scenario_numbers' and 'analysis_numbers' must have equal length"))
  }

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  analyses_list <- vector(mode = "list", length = length(scenario_numbers))

  for (s in seq_along(scenario_numbers)) {

    analyses_list[[s]] <- readRDS(
      file.path(load_path,
                paste0("analysis_data_", scenario_numbers[s], "_", analysis_numbers[s], ".rds"))
    )

  }

  names(analyses_list) <- paste0("scenario_", scenario_numbers)
  class(analyses_list) <- "analysis_list"

  return (analyses_list)

}

mapUniqueTrials <- function (

  scenario_list,
  method_quantiles_list,
  trials_unique_calc,
  applicable_previous_trials

) {

  method_names     <- names(method_quantiles_list)
  scenario_numbers <- sapply(scenario_list, function (x) x$scenario_number)

  ## Create hash tables for results for easy retrieval

  hash_keys        <- getHashKeys(trials_unique_calc)
  hash_tables_list <- vector(mode = "list", length = length(method_quantiles_list))

  for (n in seq_along(hash_tables_list)) {

    hash_tables_list[[n]] <- createHashTable(hash_keys, method_quantiles_list[[n]])

  }

  ## prepare foreach
  exported_stuff <- c("convertVector2Matrix")

  ## run foreach
  "%do%" <- foreach::"%do%"
  scenario_method_quantiles_list <- foreach::foreach(k = seq_along(scenario_numbers),
                                                     .verbose  = FALSE,
                                                     .export   = exported_stuff
  ) %do% {

    ## Find the indices of the trials of a specific scenario for go trials
    scenario_data_matrix <- cbind(scenario_list[[k]]$n_responders,
                                  scenario_list[[k]]$n_subjects)

    ## check whether there where previous analyses
    if (applicable_previous_trials) {

      scenario_go_flags         <- scenario_list[[k]]$previous_analyses$go_decisions[, 1] > 0
      scenario_method_quantiles <- scenario_list[[k]]$previous_analyses$post_quantiles

    } else {

      scenario_go_flags         <- rep(TRUE, length = nrow(scenario_data_matrix))
      scenario_method_quantiles <- vector(mode = "list", length = length(method_names))
      names(scenario_method_quantiles) <- method_names

    }

    ## In case there are trial realizations that need updating
    ## This should only not be the case if all trial realizations of a scenario have a NoGo decision
    ## and there are applicable previous trials.
    if (any(scenario_go_flags)) {

      ## Get search keys
      scenario_data_matrix_go <- convertVector2Matrix(scenario_data_matrix[scenario_go_flags, ])
      search_keys             <- getHashKeys(scenario_data_matrix_go)

      ## Save scenario specific posterior quantiles for each method
      for (n in seq_along(method_names)) {

        scenario_method_quantiles[[method_names[n]]][scenario_go_flags] <-
          getHashValues(search_keys, hash_tables_list[[n]])

      }

    }

    return (scenario_method_quantiles)

  }

  names(scenario_method_quantiles_list) <- paste0("scenario_", scenario_numbers)

  return (scenario_method_quantiles_list)

}

## Wrapper of getPostQuantiles() for specifying several scenarios
## Returns a list of quantiles of posterior distributions according to supplied methods.
#' @title performAnalyses
#' @md
#' @description This function performs the analysis of simulated or observed trial data with the
#' specified methods
#' and returns the quantiles of the posterior response rates
#' @param scenario_list An object of class `scenario_list`,
#' as e.g. created with \code{\link[bhmbasket]{simulateScenarios}}
#' @param evidence_levels A vector of numerics in `(0, 1)` for the
#' `1-evidence_levels`-quantiles of the posterior response rates to be saved.
#' Default: `c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975)`
#' @param method_names A vector of strings for the names of the methods to be used. Must
#' be one of the default values, Default: `c("berry", "exnex", "exnex_adj", "pooled", "stratified", "MEM")`
#' @param target_rates A vector of numerics in `(0, 1)` for the
#' target rates of each cohort, Default: `NULL`
#' @param prior_parameters_list An object of class `prior_parameters_list`,
#' as e.g. created with \code{\link[bhmbasket]{getPriorParameters}}
#' @param calc_differences A matrix of positive integers with 2 columns.
#' For each row the differences will be calculated.
#' Also a vector of positive integers can be provided for a single difference.
#' The integers are the numbers for the cohorts to be subtracted from one another.
#' E.g. providing `c(2, 1)` calculates the difference between cohort `2` and cohort `1`.
#' If `NULL`, no subtractions are performed, Default: `NULL`
#' @param n_mcmc_iterations A positive integer for the number of MCMC iterations,
#' see Details, Default: `10000`.
#' If `n_mcmc_iterations` is present in `.GlobalEnv` and `missing(n_mcmc_iterations)`,
#' the globally available value will be used.
#' @param n_cores Argument is deprecated and does nothing as of version 0.9.3.
#' A positive integer for the number of cores for the parallelization,
#' Default: `1`
#' @param seed Argument is deprecated and does nothing as of version 0.9.3.
#' A numeric for the random seed, Default: `1`
#' @param verbose A logical indicating whether messages should be printed, Default: `TRUE`
#' @return An object of class `analysis_list`.
#' @details
#' This function applies the following analysis models to (simulated) scenarios of class
#' `scenario_list`:
#' \itemize{
#'   \item Bayesian hierarchical model (BHM) proposed by Berry et al. (2013): `"berry"`
#'   \item BHM proposed by Neuenschwander et al. (2016): `"exnex"`
#'   \item BHM that combines above approaches: `"exnex_adj"`
#'   \item Pooled beta-binomial approach: `"pooled"`
#'   \item Stratified beta-binomial approach: `"stratified"`
#' }
#' The posterior distributions of the BHMs are approximated with Markov chain Monte Carlo (MCMC)
#' methods implemented in JAGS.
#' Two independent chains are used with each `n_mcmc_iterations` number of MCMC iterations.
#' The first `floor(n_mcmc_iterations / 3)` number of iterations are discarded as burn-in period.
#' No thinning is applied.
#'
#' Note that the value for `n_mcmc_iterations` required for a good approximation of the posterior
#' distributions depends on the analysis model, the investigated scenarios, and the use case.
#' The default value might be a good compromise between run-time and approximation for
#' the estimation of decision probabilities, but
#' it should definitively be increased for the analysis of a single trial's outcome.
#'
#' The analysis models will only be applied to the unique trial realizations across
#' all simulated scenarios.
#' The models can be applied in parallel by registering a parallel backend for the 'foreach'
#' framework, e.g. with `doFuture::registerDoFuture()` and `future::plan(future::multisession)`.
#' The parallelization is nested, so that the resources of a HPC environment can be used
#' efficiently.
#' For more on this topic, kindly see the respective vignette.
#' The tasks that are to be performed in parallel are chunked according to the number of workers
#' determined with `foreach::getDoParWorkers()`.
#'
#' The JAGS code for the BHM `"exnex"` was taken from Neuenschwander et al. (2016).
#' The JAGS code for the BHM `"exnex_adj"` is based on the JAGS code for `"exnex"`.
#' @seealso
#'  \code{\link[bhmbasket]{simulateScenarios}}
#'  \code{\link[bhmbasket]{createTrial}}
#'  \code{\link[bhmbasket]{getPriorParameters}}
#' @rdname performAnalyses
#' @author Stephan Wojciekowski
#' @examples
#'  trial_data <- createTrial(
#'    n_subjects   = c(10, 20, 30),
#'    n_responders = c(1, 2, 3))
#'
#'  analysis_list <- performAnalyses(
#'    scenario_list      = trial_data,
#'    target_rates       = rep(0.5, 3),
#'    calc_differences   = matrix(c(3, 2, 1, 1), ncol = 2),
#'    n_mcmc_iterations  = 100)
#' @references Berry, Scott M., et al. "Bayesian hierarchical modeling of patient subpopulations:
#' efficient designs of phase II oncology clinical trials."
#' \emph{Clinical Trials} 10.5 (2013): 720-734.
#' @references Neuenschwander, Beat, et al. "Robust exchangeability designs
#' for early phase clinical trials with multiple strata."
#' \emph{Pharmaceutical statistics} 15.2 (2016): 123-134.
#' @references Plummer, Martyn. "JAGS: A program for analysis of Bayesian graphical models
#' using Gibbs sampling."
#' \emph{Proceedings of the 3rd international workshop on distributed statistical computing.}
#' Vol. 124. No. 125.10. 2003.
#' @export
performAnalyses <- function (

  scenario_list,
  evidence_levels       = c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975),

  method_names          = c("berry", "exnex", "exnex_adj", "pooled", "stratified"),
  target_rates          = NULL,
  prior_parameters_list = NULL,

  calc_differences      = NULL,

  n_mcmc_iterations     = 1e4,
  n_cores               = 1,
  seed                  = 1,
  verbose               = TRUE,
  custom_methods        = NULL

) {
print("hello world!")
  error_scenario_list <-
    simpleError("Please provide an object of class scenario_list for the argument 'scenario_list'")
  error_evidence_levels <-
    simpleError("Please provide a vector of numerics in (0, 1) for the argument 'evidence_levels'")
  error_method_names <-
    simpleError(paste("Please provide a (vector of) strings for the argument 'method_names'\n",
                      "Must be one of 'berry', 'exnex', 'exnex_adj', 'pooled', 'stratified', 'custom'"))
  #error_custom_methods<-SimpleError("Please provide a list of custom methods for the arugment 'custom_methods'.")
  error_target_rates <-
    simpleError(paste("Please provide either 'NULL' or a vector of numerics in (0, 1)",
                      "for the argument 'target_rates'"))
  error_prior_parameters_list <-
    simpleError("Please provide either 'NULL' or an object of class 'prior_parameters_list'")
  error_calc_differences <-
    simpleError(paste("Please provide either 'NULL' or a matrix of integers with ncol = 2.",
                      "The values of the integers must be less than or equal to the number",
                      "of cohorts"))
  error_n_mcmc_iterations <-
    simpleError("Please provide a positive integer for the argument 'n_mcmc_iterations'")
  error_verbose <-
    simpleError("Please provide a logical for the argument 'verbose'")

  warning_n_cores <- "The argument 'n_cores' is deprecated as of version 0.9.3."
  warning_seed    <- "The argument 'seed' is deprecated as of version 0.9.3."

  if (!missing(n_cores)) warning(warning_n_cores)
  if (!missing(seed))    warning(warning_seed)

  if (missing(scenario_list)) stop (error_scenario_list)

  method_names <- tryCatch({

    match.arg(
      method_names,
      choices    = c('berry', 'exnex', 'exnex_adj', 'pooled', 'stratified', 'MEM', 'custom'),
      several.ok = TRUE)

  }, error = function (e) e)

  if (!is.scenario_list(scenario_list))                   stop (error_scenario_list)
  if (!is.numeric.in.zero.one(evidence_levels))           stop (error_evidence_levels)
  if (inherits(method_names, "error"))                    stop (error_method_names)
 if (!is.null(custom_methods)&&!is.list(custom_methods)) stop (error_custom_methods)
 if (!is.null(target_rates) &&
     !is.numeric.in.zero.one(target_rates))              stop (error_target_rates)
  if (!is.null(prior_parameters_list) &&
      !is.prior_parameters_list(prior_parameters_list))   stop (prior_parameters_list)

  if (is.null(target_rates)) {
    if (any(c("berry", "exnex_adj", "custom") %in% method_names)) stop (simpleError(
      "Please provide 'target_rates' when using the methods 'berry' and/or 'exnex_adj' and/or 'custom'"))
    if (is.null(prior_parameters_list)) stop (simpleError(
      "Please provide at least one of 'prior_parameters_list' or 'target_rates'"))
  } else {
    if (!identical(length(target_rates), ncol(scenario_list[[1]]$n_subjects))) stop (simpleError(
      "The length of 'target_rates' does not match the number of cohorts"))
  }

  if (!is.null(prior_parameters_list)) {
    if (!all(method_names %in% names(prior_parameters_list))) stop (simpleError(
      paste("Not all specified methods in 'method_names'",
            "have prior parameters specified in 'prior_parameters_list'")))
    if (any(sapply(names(prior_parameters_list), function (name) {
      if (name %in% c('exnex', 'exnex_adj', 'stratified', 'MEM', 'custom')) {
        !identical(max(sapply(prior_parameters_list[[name]], length)),
                   ncol(scenario_list[[1]]$n_subjects))
      } else FALSE
    }))) stop (simpleError(paste(
      "The number of cohorts specified in 'prior_parameters_list' does not match",
      "the number of cohorts specified in 'scenario_list'")))
  }

  n_cohorts_min <- min(sapply(scenario_list, function (x) {
    ncol(x$n_responders)
  }))
  if (!is.null(calc_differences) && (
    !is.numeric(calc_differences) ||
    !(identical(length(calc_differences), 2L) ||
      identical(ncol(calc_differences), 2L)) ||
    !is.positive.wholenumber(calc_differences) ||
    max(calc_differences) > n_cohorts_min))            stop (error_calc_differences)
  rm (n_cohorts_min)

  ## check whether n_mcmc_iterations is present in global environment
  if ("n_mcmc_iterations" %in% ls(envir = .GlobalEnv) & missing(n_mcmc_iterations)) {
    n_mcmc_iterations <- get("n_mcmc_iterations", envir = .GlobalEnv)
  }

  if (!is.single.positive.wholenumber(n_mcmc_iterations)) stop (error_n_mcmc_iterations)
  if (!is.logical(verbose))                               stop (error_verbose)

  ## check for parallel backend
  if (!all(sapply(method_names,
                  function (x) grepl(x, "stratified") | grepl(x, "pooled") | grepl(x, "MEM")))) {

    checkForParallelBackend()

  }

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  ## message to user
  if (verbose) message(format(Sys.time(), "%d-%h-%Y"), " Performing Analyses")

  ## some housekeeping
  method_names <- sort(method_names)
  quantiles    <- sort(unique(round(1 - c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975,
                                          evidence_levels), 9)))
  if (!is.null(calc_differences)) {
    calc_differences <- convertVector2Matrix(calc_differences)
  }

  ## get scenario numbers
  scenario_numbers <- sapply(scenario_list, function (x) x$scenario_number)

  ## get unique trials over all scenarios
  trials_unique <- getUniqueTrials(scenario_list)
  n_cohorts     <- (ncol(trials_unique) - 1L) / 2


  ## analyze only unique trials that have not been previously analyzed
  applicable_previous_trials <- applicablePreviousTrials(
    scenario_list    = scenario_list,
    method_names     = method_names,
    quantiles        = quantiles,
    n_cohorts        = n_cohorts,
    calc_differences = calc_differences)

  ## only get previous go indices if all conditions for previous trials are met
  if (applicable_previous_trials) {
    calc_trial_indices <- trials_unique[, ncol(trials_unique)] > 0
  } else {
    calc_trial_indices <- rep(TRUE, nrow(trials_unique))
  }

  ## get resulting unique number of responders and number of subjects
  trials_unique_calc <- trials_unique[calc_trial_indices, -ncol(trials_unique)]
  n_responders       <- trials_unique_calc[, seq_len(n_cohorts)]
  n_subjects         <- trials_unique_calc[, seq_len(n_cohorts) + n_cohorts]

  ## message to user
  if (verbose) {

    message("         Analyzing ", length(scenario_numbers) ," scenario", ifelse(length(scenario_numbers) == 1, "", "s")," ",
            "(", nrow(n_responders), " unique", ifelse(applicable_previous_trials, " updated ", " "),
            "trial realization", ifelse(nrow(trials_unique) == 1, "", "s"),")")

  }

  ## check if we have a custom model 
  custom_available<- FALSE
  if ('custom' %in% method_names) {
    method_names <- method_names[-which(method_names == 'custom')]
    custom_available<-TRUE
  }

  ## get default prior parameters if needed

  ## beginning here have to cut out the standard model 
  if((is.null(prior_parameters_list))&(length(method_names!=0))) {

    prior_parameters_list <- getPriorParameters(
      method_names = method_names,
      target_rates = target_rates)

  }

  ## Create lists to save all results of the unique trials
  #method_quantiles_list        <- vector(mode = "list", length = length(method_names))
  method_quantiles_list        <- ifelse(is.null(custom_methods),vector(mode = "list", length = length(method_names)), vector(mode = "list", length = length(method_names)+length(custom_methods)))

  names(method_quantiles_list) <- ifelse(is.null(custom_methods),method_names, c(method_names, names(custom_methods)))

  ## Create lists to save all results of the unique trials
  #method_quantiles_list        <- vector(mode = "list", length = length(method_names))
  # method_samples_list        <- ifelse(is.null(custom_methods),vector(mode = "list", length = length(method_names)), vector(mode = "list", length = length(method_names)+length(custom_methods)))
  # 
  # names(method_samples_list) <- ifelse(is.null(custom_methods),method_names, c(method_names, names(custom_methods)))
  # 
  
  ## For each method
  for (n in seq_along(method_names)) {

    ## message to user
    if (verbose) {
      start_time  <- Sys.time()
      out_message <- paste0(format(start_time, "   %H:%M", digits = 1),
                            " - with ", firstUpper(method_names[n]), " ...")
      message(out_message, rep(".", 33 - nchar(out_message)))
    }

    ## prepare analysis
    prepare_analysis <- prepareAnalysis(
      method_name       = method_names[n],
      target_rates      = target_rates,
      prior_parameters  = prior_parameters_list[[method_names[n]]])

    ## run analysis
    method_quantiles_list[[method_names[n]]] <- getPostQuantiles(
      method_name       = method_names[n],
      quantiles         = quantiles,
      scenario_data     = list(n_subjects   = n_subjects,
                               n_responders = n_responders),
      calc_differences  = calc_differences,
      j_parameters      = prepare_analysis$j_parameters,
      j_model_file      = prepare_analysis$j_model_file,
      j_data            = prepare_analysis$j_data,
      n_mcmc_iterations = n_mcmc_iterations,
      save_path         = NULL,
      save_trial        = NULL)#[[2]]
    

    ## message to user
    if (verbose) {
      message("             finished after ", round(Sys.time() - start_time, 1), " ",
              units(Sys.time() - start_time), ".")
      rm(start_time)
    }

  }

  ## custom methods 
  if((!is.null(custom_methods))&(custom_available==TRUE)){
  for (n in seq_along(custom_methods)) {

    ## message to user
    if (verbose) {
      start_time  <- Sys.time()
      out_message <- paste0(format(start_time, "   %H:%M", digits = 1),
                            " - with ", firstUpper(names(custom_methods)[n]), " ...")
      message(out_message, rep(".", 33 - nchar(out_message)))
    }

    ## prepare analysis
    prepare_analysis <- prepareAnalysis(
      method_name       = names(custom_methods)[n],
      custom_method    = custom_methods[[n]],
      target_rates      = target_rates,
      prior_parameters  = NULL)

    ## run analysis
    method_quantiles_list[[names(custom_methods)[n]]] <- getPostQuantiles(
      method_name       = names(custom_methods)[n],
      quantiles         = quantiles,
      scenario_data     = list(n_subjects   = n_subjects,
                               n_responders = n_responders),
      calc_differences  = calc_differences,
      j_parameters      = prepare_analysis$j_parameters,
      j_model_file      = prepare_analysis$j_model_file,
      j_data            = prepare_analysis$j_data,
      n_mcmc_iterations = n_mcmc_iterations,
      save_path         = NULL,
      save_trial        = NULL)
    
    prior_parameters_list[[names(custom_methods)[n]]]<-prepare_analysis$j_data[-which(names((prepare_analysis$j_data)) %in% c("p_t", "J"))]

   ## message to user
    if (verbose) {
      message("             finished after ", round(Sys.time() - start_time, 1), " ",
              units(Sys.time() - start_time), ".")
      rm(start_time)
    }

  }
  }

  ## message to user
  if (verbose) {
    start_time  <- Sys.time()
    message("         Processing scenarios ...")
  }

  ## Process scenarios
  scenario_method_quantiles_list <- mapUniqueTrials(
    scenario_list              = scenario_list,
    method_quantiles_list      = method_quantiles_list,
    trials_unique_calc         = trials_unique_calc,
    applicable_previous_trials = applicable_previous_trials)

  ## Process scenarios
  # scenario_method_samples_list <- mapUniqueTrials(
  #   scenario_list              = scenario_list,
  #   method_quantiles_list      = method_samples_list,
  #   trials_unique_calc         = trials_unique_calc,
  #   applicable_previous_trials = applicable_previous_trials)
  # 
  ## message to user
  if (verbose) {
    message("             finished after ", round(Sys.time() - start_time, 1), " ",
            units(Sys.time() - start_time), ".")
    rm(start_time)
  }

  ## combine results from all scenarios & return
  analyses_list        <- vector(mode = "list", length = length(scenario_numbers))
  names(analyses_list) <- paste0("scenario_", scenario_numbers)

  if((!is.null(custom_methods))&(custom_available==TRUE)) {
    method_names<-c(method_names, names(custom_methods))

  }

  for (s in seq_along(scenario_numbers)) {
    analyses_list[[s]] <- list(
      quantiles_list      = scenario_method_quantiles_list[[s]],
      #samples_list      = scenario_method_samples_list[[s]],
      scenario_data       = scenario_list[[s]],
      analysis_parameters = list(
        quantiles             = quantiles,
        method_names          = method_names,
        prior_parameters_list = prior_parameters_list,
        n_mcmc_iterations     = n_mcmc_iterations))

  }



  class(analyses_list) <- "analysis_list"

  return (analyses_list)

}


#' @title performAnalysesNormal
#' @md
#' @description
#' Analyse scenarios with a continuous (normal) endpoint using a Bayesian
#' hierarchical normal model across baskets. The output structure mirrors that
#' of \code{\link[bhmbasket]{performAnalyses}} so that the same OC and plotting
#' functions can be applied (where they only depend on the analysis_list
#' structure and not on binary-specific fields).
#'
#' @param scenario_list An object of class \code{"scenario_list_normal"}
#'   as created by \code{\link[bhmbasket]{simulateScenariosNormal}}.
#' @param evidence_levels A numeric vector of evidence levels in (0, 1).
#'   These are mapped to quantiles via \code{1 - evidence_levels} and stored
#'   in \code{analysis_parameters$quantiles}.
#' @param n_mcmc_iterations A positive integer for total MCMC iterations per chain.
#' @param seed Integer RNG seed.
#'
#' @return An object of class \code{"analysis_list"} with one element per
#'   scenario, each containing \code{quantiles_list}, \code{scenario_data},
#'   and \code{analysis_parameters}.
#' @export
performAnalysesNormal <- function(
    scenario_list,
    evidence_levels    = c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975),
    n_mcmc_iterations  = 1e4,
    seed               = 1,
    # hyperparameters for the IG priors and beta precision
    a0                 = 0.5,
    b0                 = 0.05,
    a_prime0           = 0.5,
    b_prime0           = 0.05,
    lambda_inv         = 1
) {
  
  error_scenario_list <- simpleError(
    "Please provide an object of class 'scenario_list_normal' for the argument 'scenario_list'")
  error_evidence_levels <- simpleError(
    "Please provide a vector of numerics in (0, 1) for the argument 'evidence_levels'")
  error_n_mcmc_iterations <- simpleError(
    "Please provide a single positive integer for the argument 'n_mcmc_iterations'")
  
  if (missing(scenario_list)) stop(error_scenario_list)
  if (!inherits(scenario_list, "scenario_list_normal")) stop(error_scenario_list)
  
  if (missing(evidence_levels) ||
      !is.numeric.in.zero.one(evidence_levels)) stop(error_evidence_levels)
  
  if (missing(n_mcmc_iterations) ||
      !is.single.positive.wholenumber(n_mcmc_iterations)) stop(error_n_mcmc_iterations)
  
  set.seed(seed)
  
  n_scenarios   <- length(scenario_list)
  analyses_list <- vector("list", n_scenarios)
  
  ## match performAnalyses convention: store posterior quantiles
  quantiles <- sort(unique(round(1 - c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975,
                                       evidence_levels), 9)))
  
  ## JAGS model file (your new model)
  jags_model_string <- "
  model {

    # --- Likelihood ---
    for (k in 1:K) {

      # Control arm
      for (i in 1:n_control[k]) {
        y_control[k, i] ~ dnorm(mu_control[k, i], prec_sigma)
        mu_control[k, i] <- inprod(X_control[k, i, ], beta[k, ])
      }

      # Treatment arm
      for (i in 1:n_treatment[k]) {
        y_treatment[k, i] ~ dnorm(mu_treatment[k, i], prec_sigma)
        mu_treatment[k, i] <- inprod(X_treatment[k, i, ], beta[k, ]) + tau[k]
      }
    }

    # --- Hierarchical structure for treatment effects ---
    for (k in 1:K) {
      tau[k] ~ dnorm(mu_tau, prec_tau_shrink)

      for (r in 1:num_predictors) {
        beta[k, r] ~ dnorm(0, prec_beta[k])
      }
      prec_beta[k] <- prec_sigma * lambda_inv
    }

    # Population mean for treatment effects
    mu_tau ~ dnorm(0, 0.0001)

    # Shrinkage for tau (Inverse-Gamma on sigma2_tau via gamma on precision)
    prec_tau_shrink ~ dgamma(a_prime0, b_prime0)
    sigma2_tau <- 1 / prec_tau_shrink

    # Residual variance (Inverse-Gamma prior)
    prec_sigma ~ dgamma(a0, b0)
    sigma2 <- 1 / prec_sigma
  }
  "
  
  j_model_file <- tempfile(pattern = "bhm_normal_", fileext = ".bug")
  writeLines(jags_model_string, con = j_model_file)

  for (s in seq_along(scenario_list)) {

    scen      <- scenario_list[[s]]
    trials    <- scen$trials
    n_trials  <- length(trials)

    ## Determine K and num_predictors from first trial
    first_tr  <- trials[[1]]

    # y_control and y_treatment are lists of length K
    K <- length(first_tr$y_control)

    n_control   <- first_tr$n_control
    n_treatment <- first_tr$n_treatment

    if (length(n_control) != K || length(n_treatment) != K) {
      stop("Inconsistent lengths of n_control / n_treatment vs y_control / y_treatment.")
    }

    # determine number of predictors from first basket's X_control (or X_treatment)
    if (!is.null(first_tr$X_control) && length(first_tr$X_control) > 0) {
      num_predictors <- ncol(first_tr$X_control[[1]])
    } else if (!is.null(first_tr$X_treatment) && length(first_tr$X_treatment) > 0) {
      num_predictors <- ncol(first_tr$X_treatment[[1]])
    } else {
      stop("X_control or X_treatment must be provided with at least one predictor (e.g., intercept)." )
    }

    quantiles_list <- list()
    quantiles_list[["bhm_normal"]] <- vector("list", n_trials)

    for (t in seq_len(n_trials)) {

      tr <- trials[[t]]

      # Each of these should be lists of length K:
      y_ctrl_list <- tr$y_control
      y_trt_list  <- tr$y_treatment
      X_ctrl_list <- tr$X_control
      X_trt_list  <- tr$X_treatment
      n_control   <- tr$n_control
      n_treatment <- tr$n_treatment

      if (length(y_ctrl_list) != K || length(y_trt_list) != K) {
        stop("y_control and y_treatment must be lists of length K for each trial.")
      }

      # Max sample sizes per arm across baskets (for array dimensions)
      max_n_ctrl <- max(n_control)
      max_n_trt  <- max(n_treatment)

      # Allocate matrices/arrays
      y_control_mat   <- matrix(NA_real_, nrow = K, ncol = max_n_ctrl)
      y_treatment_mat <- matrix(NA_real_, nrow = K, ncol = max_n_trt)

      X_control_arr   <- array(0, dim = c(K, max_n_ctrl, num_predictors))
      X_treatment_arr <- array(0, dim = c(K, max_n_trt,  num_predictors))

      # Fill them
      for (k in seq_len(K)) {

        # control
        if (n_control[k] > 0) {
          y_control_mat[k, seq_len(n_control[k])] <- y_ctrl_list[[k]]
          if (!is.null(X_ctrl_list[[k]])) {
            X_control_arr[k, seq_len(n_control[k]), ] <- X_ctrl_list[[k]]
          } else {
            # default to intercept-only: 1
            X_control_arr[k, seq_len(n_control[k]), ] <- 1
          }
        }

        # treatment
        if (n_treatment[k] > 0) {
          y_treatment_mat[k, seq_len(n_treatment[k])] <- y_trt_list[[k]]
          if (!is.null(X_trt_list[[k]])) {
            X_treatment_arr[k, seq_len(n_treatment[k]), ] <- X_trt_list[[k]]
          } else {
            # default to intercept-only: 1
            X_treatment_arr[k, seq_len(n_treatment[k]), ] <- 1
          }
        }
      }

      j_data <- list(
        K             = K,
        n_control     = n_control,
        n_treatment   = n_treatment,
        y_control     = y_control_mat,
        y_treatment   = y_treatment_mat,
        X_control     = X_control_arr,
        X_treatment   = X_treatment_arr,
        num_predictors = num_predictors,
        lambda_inv    = lambda_inv,
        a0            = a0,
        b0            = b0,
        a_prime0      = a_prime0,
        b_prime0      = b_prime0
      )

      posterior_samples <- performJags(
        data               = j_data,
        parameters_to_save = c("tau", "mu_tau", "prec_tau_shrink", "prec_sigma"),
        model_file         = j_model_file,
        n_chains           = 2,
        n_iter             = n_mcmc_iterations,
        n_burnin           = floor(n_mcmc_iterations / 3)
      )

      ## Extract tau[k] posterior samples (treatment effects)
      tau_cols <- grepl("^tau\\[", colnames(posterior_samples))
      tau_post <- posterior_samples[, tau_cols, drop = FALSE]

      posterior_quantiles <- posteriors2Quantiles(
        quantiles  = quantiles,
        posteriors = tau_post
      )

      colnames(posterior_quantiles) <- paste0("p_", seq_len(K))

      quantiles_list[["bhm_normal"]][[t]] <- posterior_quantiles
    }

    scenario_name <- names(scenario_list)[s]

    scenario_data <- list(
      scenario_number = scen$scenario_number,
      # you can keep these if you simulate them:
      true_means      = scen$true_means,    # interpret as TRUE tau[k] here
      sd              = scen$sd,
      n_trials        = scen$n_trials,
      endpoint        = "normal"
    )

    analysis_parameters <- list(
      quantiles          = quantiles,
      method_names       = "bhm_normal",
      n_mcmc_iterations  = n_mcmc_iterations,
      seed               = seed,
      a0                 = a0,
      b0                 = b0,
      a_prime0           = a_prime0,
      b_prime0           = b_prime0,
      lambda_inv         = lambda_inv
    )

    analyses_list[[s]] <- list(
      quantiles_list      = quantiles_list,
      scenario_data       = scenario_data,
      analysis_parameters = analysis_parameters
    )
    names(analyses_list)[s] <- scenario_name
  }

  class(analyses_list) <- "analysis_list"
  return(analyses_list)
}

## based on R2jags::jags
##  stripped down to improve performance
performJags <- function (

  data,
  parameters_to_save,
  model_file,
  n_chains = 2,
  n_iter   = 1e4,
  n_burnin = floor(n_iter/3)

) {


  n_adapt <- ifelse(n_burnin > 0, n_burnin, 100)

  inits <- vector("list", n_chains)
  for (i in 1:n_chains) {
    inits[[i]]$.RNG.name <- "base::Wichmann-Hill"
    inits[[i]]$.RNG.seed <- stats::runif(1, 0, 2^31)
  }

  j_model <- rjags::jags.model(file     = model_file,
                               data     = data,
                               inits    = inits,
                               n.chains = n_chains,
                               n.adapt  = 0,
                               quiet    = TRUE)

  rjags::adapt(object         = j_model,
               n.iter         = n_adapt,
               progress.bar   = "none",
               end.adaptation = TRUE)

  samples <- rjags::coda.samples(model          = j_model,
                                 variable.names = parameters_to_save,
                                 n.iter         = n_iter - n_burnin,
                                 thin           = 1,
                                 progress.bar   = "none")

  return(do.call(rbind, samples))

}

posteriors2Quantiles <- function (

  quantiles,
  posteriors

) {

  posterior_quantiles <- apply(posteriors, 2, function (x) stats::quantile(x, probs = quantiles))

  posterior_mean      <- apply(posteriors, 2, mean)
  posterior_sd        <- apply(posteriors, 2, stats::sd)
  posterior_quantiles <- rbind(posterior_quantiles,
                               Mean = posterior_mean,
                               SD   = posterior_sd)

  return (posterior_quantiles)

}

prepareAnalysis <- function (

  method_name,
  custom_method = NULL,
  prior_parameters = NULL,
  target_rates     = NULL

) {
  if(! is.null(custom_method)){

      j_data <- custom_method$j_data
      j_data$J <- ifelse( is.vector(target_rates),length(target_rates),length(target_rates[[1]]))
      j_model_file <- system.file(package = "bhmbasket", "jags_models", custom_method$j_model_file, mustWork = TRUE)
      j_parameters <- custom_method$j_parameters
  

  } else if (method_name == "berry") {

    j_data <- list(mean_mu       = prior_parameters$mu_mean,
                   precision_mu  = prior_parameters$mu_sd^-2,
                   precision_tau = prior_parameters$tau_scale^-2,
                   p_t           = target_rates,
                   J             = ifelse( is.vector(target_rates),length(target_rates),length(target_rates[[1]])))

    # j_model_file <- writeTempModel(method_name = "berry")
    j_model_file <- getModelFile(method_name = "berry", custom_methods= custom_methods)

    j_parameters <- c("p", "mu", "tau")

  } else if (method_name == "exnex" | method_name == "exnex_adj") {
    # Nexch: number of exchangeable mixture components
    # Nmix:  number of mixture components
    j_data <- list(Nexch        = length(prior_parameters$mu_mean),
                   Nmix         = length(prior_parameters$mu_mean) + 1L,
                   Nstrata      = length(prior_parameters$mu_j),
                   mu_mean      = prior_parameters$mu_mean,
                   mu_prec      = prior_parameters$mu_sd^-2,
                   tau_HN_scale = rep(prior_parameters$tau_scale,
                                      length(prior_parameters$mu_mean)), # rep(..., Nexch)
                   nex_mean     = prior_parameters$mu_j,
                   nex_prec     = prior_parameters$tau_j^-2)

    if (identical(length(prior_parameters$w_j), 1L)) {
      j_data$pMix <- c(prior_parameters$w_j, 1 - prior_parameters$w_j)
    } else {
      j_data$pMix <- prior_parameters$w_j
    }

    if (method_name == "exnex") {

      j_model_file    <- getModelFile(method_name = "exnex")

    } else {

      j_data$p_target <- target_rates
      j_model_file    <- getModelFile(method_name = "exnex_adj")

    }

    j_parameters <- c("p", "mu", "tau", "exch")

  } else if (method_name == "stratified" | method_name == "pooled" | method_name== "MEM") {

    ## For methods "stratified" and "pooled" no MCMC simulations are necessary,
    ## as the posterior response rates of the cohorts follow known beta distributions.

    j_model_file <- "dummy path to JAGS model"
    j_parameters <- "dummy JAGS parameters"
    j_data       <- prior_parameters

  } else {

    stop ("method_name must be one of berry, exnex, exnex_adj, stratified, pooled, MEM")

  }

  return (list(j_parameters = j_parameters,
               j_model_file = j_model_file,
               j_data       = j_data))
}

#' @export
print.analysis_list <- function (x, digits = 2, ...) {

  n_scenarios    <- length(x)
  scenario_names <- names(x)

  n_methods      <- length(x[[1]]$quantiles_list)
  method_names   <- names(x[[1]]$quantiles_list)

  estimates          <- getEstimates(x)
  n_mcmc_interations <- x[[1]]$analysis_parameters$n_mcmc_iterations

  evidence_levels <- sort(1 - x[[1]]$analysis_parameters$quantiles)

  cat("analysis_list of ", n_scenarios, " scenario", ifelse(n_scenarios == 1, "", "s"),
      " with ", n_methods, " method", ifelse(n_methods == 1, "", "s"),"\n\n", sep = "")

  for (n in seq_along(scenario_names)) {

    if (n_scenarios == 1L) {

      expr <- quote(t(y[, 1:2]))

    } else {

      expr <- quote(t(y[[n]][, 1:2]))

    }

    mat_out <- do.call(rbind, lapply(estimates, function (y) eval(expr)))

    rownames(mat_out) <-  paste0(
      c("    - ", "      "),
      c(rbind(
        paste0(
          firstUpper(method_names),
          sapply(method_names, function (y) {
            getBlankString(max(nchar(method_names)) - nchar(y) + 1)
          })),
        rep(getBlankString(max(nchar(method_names)) + 3),
            length = length(method_names))
      )),
      rownames(mat_out))

    cat("  -", scenario_names[n], "\n")
    print(round(mat_out, digits = digits))

    cat("\n")

  }

  cat("  -", n_mcmc_interations, "MCMC iterationns per BHM method\n")
  cat("  - Available evidence levels:", evidence_levels, "\n")

}

qbetaDiff <- function (

  quantiles,

  x_1_shape1,
  x_1_shape2,

  x_2_shape1,
  x_2_shape2,

  n_mcmc = 1e6

) {

  sample_1   <- stats::rbeta(n_mcmc, shape1 = x_1_shape1, shape2 = x_1_shape2)
  sample_2   <- stats::rbeta(n_mcmc, shape1 = x_2_shape1, shape2 = x_2_shape2)
  difference <- sample_1 - sample_2

  quantiles_diff <- stats::quantile(difference, probs = quantiles)

  mean_diff      <- mean(difference)
  sd_diff        <- stats::sd(difference)
  quantiles_diff <- c(quantiles_diff, mean_diff, sd_diff)

  return (quantiles_diff)

}


#' @title saveAnalyses
#' @md
#' @description This function saves an object of class `analysis_list`
#' @param analyses_list An object of class `analysis_list`,
#' as created with \code{\link[bhmbasket]{performAnalyses}}
#' @param save_path A string for the path where the scenarios are being stored,
#' Default: \code{\link[base]{tempfile}}
#' @param analysis_numbers A positive integer naming the analysis number.
#' If `NULL`, the function will look for the number of saved analyses of the scenario
#' in the directory and add 1, Default: `NULL`
#' @return A named list of length 3 of vectors with scenario and analysis numbers and
#' the `save_path`
#' @seealso
#'  \code{\link[bhmbasket]{performAnalyses}}
#'  \code{\link[bhmbasket]{loadAnalyses}}
#'  \code{\link[base]{tempfile}}
#' @rdname saveAnalyses
#' @examples
#'   trial_data <- createTrial(
#'     n_subjects   = c(10, 20, 30),
#'     n_responders = c(1, 2, 3))
#'
#'   analysis_list <- performAnalyses(
#'     scenario_list      = trial_data,
#'     target_rates       = rep(0.5, 3),
#'     n_mcmc_iterations  = 100)
#'
#'   save_info     <- saveAnalyses(analysis_list)
#'   analysis_list <- loadAnalyses(scenario_numbers = save_info$scenario_numbers,
#'                                 analysis_numbers = save_info$analysis_numbers,
#'                                 load_path        = save_info$path)
#' @author Stephan Wojciekowski
#' @export
saveAnalyses <- function (

  analyses_list,
  save_path        = tempdir(),
  analysis_numbers = NULL

) {

  error_analyses_list <- simpleError(
    "Please provide an object of class analysis_list for the argument 'analyses_list'")
  error_save_path     <- simpleError(
    "Please provide a string containing a path for the argument 'save_path'")
  error_analysis_numbers <- simpleError(paste(
    "Please provide a vector of positive integers for the argument 'analysis_numbers'",
    "with length equal to the length of 'analyses_list'"))

  if (missing(analyses_list))                                     stop (error_analyses_list)

  if (!is.analysis_list(analyses_list))                           stop (error_analyses_list)
  if (!is.character(save_path) || length(save_path) > 1)          stop (error_save_path)
  if (!is.null(analysis_numbers) && (
    any(!is.positive.wholenumber(analysis_numbers)) ||
    !identical(length(analyses_list), length(analysis_numbers)))) stop(error_analysis_numbers)

  ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ###

  scenario_numbers <- sapply(analyses_list, function (x) x$scenario_data$scenario_number)

  if (is.null(analysis_numbers)) {
    analysis_numbers <- rep(0, length(analyses_list))
  }

  for (s in seq_along(analyses_list)) {

    ## Get analysis number
    if (identical(analysis_numbers[s], 0)) {

      analysis_numbers[s] <- sum(grepl(paste0("analysis_data_", scenario_numbers[s], "_"),
                                       list.files(save_path))) + 1L

    }

    ## Save the analysis
    file_name <- paste0("analysis_data_", scenario_numbers[s], "_", analysis_numbers[s],".rds")
    saveRDS(analyses_list[[s]], file = file.path(save_path, file_name),
            compress = "xz")

  }

  return (list(scenario_numbers = scenario_numbers,
               analysis_numbers = analysis_numbers,
               path             = save_path))

}

