
test_that("throws error for invalid analyses_list class", {
  expect_error(getGoDecisions(list(), c("p_1"), c(0.5), quote(c(TRUE))), "analysis_list")
})

test_that("throws error for missing evidence_levels or boundary_rules", {
  expect_error(getGoDecisions(analyses_list, c("p_1"), boundary_rules = quote(c(TRUE))), "evidence_levels")
  expect_error(getGoDecisions(analyses_list, c("p_1"), evidence_levels = c(0.5)), "boundary_rules")
})

test_that("throws error for invalid cohort_names", {
  expect_error(getGoDecisions(analyses_list, c("invalid"), c(0.5), quote(c(TRUE))), "cohort_names")
})

test_that("throws error for invalid overall_min_gos", {
  expect_error(getGoDecisions(analyses_list, c("p_1"), c(0.5), quote(c(TRUE)), overall_min_gos = 0), "overall_min_gos")
})

test_that("handles multiple methods and replicates rules correctly", {
  decisions <- getGoDecisions(
    analyses_list   = analyses_list,
    cohort_names    = c("p_1", "p_2", "p_3"),
    evidence_levels = c(0.5, 0.5, 0.8),
    boundary_rules  = list(
      quote(c(x[1] > 0.1, x[2] < 0.5, x[3] < 0.1)),
      quote(c(x[1] > 0.2, x[2] < 0.4, x[3] < 0.2))
    )
  )
  expect_s3_class(decisions, "decision_list")
})

test_that("works with subset of cohorts and overall_min_gos", {
  decisions <- getGoDecisions(
    analyses_list   = analyses_list,
    cohort_names    = c("p_1", "p_3"),
    evidence_levels = c(0.5, 0.8),
    boundary_rules  = quote(c(x[1] > 0.7, TRUE, x[3] < 0.6)),
    overall_min_gos = 2L
  )
  expect_true("overall" %in% colnames(decisions[[1]]$decisions_list[[1]]))
})



test_that("list evidence_levels: each element is validated (valid case)", {
  # Use only levels available in analyses_list (0.5 is always safe)
  ev_list_ok <- list(rep(0.5, 3), rep(0.5, 3))
  
  expect_silent(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = ev_list_ok,
      boundary_rules  = quote(c(x[1] > 0.1, x[2] < 0.6, x[3] < 0.9))
    )
  )
})


test_that("list evidence_levels: invalid element triggers evidence_levels error", {
  # invalid: one element has a value outside (0,1)
  ev_list_bad <- list(c(0.5, 0.5, 0.8), c(1.1, 0.2, 0.3))
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = ev_list_bad,
      boundary_rules  = quote(c(x[1] > 0.1, x[2] < 0.6, x[3] < 0.9))
    ),
  )
})


test_that("boundary_rules list: non-language element fails", {
  br <- list(123)  # not quote(c(...))
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = br
    ),
    "boundary_rules"
  )
})

test_that("boundary_rules list: head is not c() fails", {
  br <- list(quote(list(TRUE, TRUE, TRUE))) # language, but not c()
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = br
    ),
    "boundary_rules"
  )
})

test_that("boundary_rules list: wrong length inside c(...) fails", {
  # scenario has 3 cohorts; give c() with 2 entries -> should fail
  br <- list(quote(c(TRUE, TRUE)))
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = br
    ),
    "boundary_rules"
  )
})


test_that("boundary_rules non-list: non-language fails", {
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = 1  # not language
    ),
    "boundary_rules"
  )
})

test_that("boundary_rules non-list: head not c() fails", {
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = quote(x[1] > 0.5)  # language, but not c()
    ),
    "boundary_rules"
  )
})

test_that("boundary_rules non-list: wrong length inside c(...) fails", {
  # scenario has 3 cohorts; give c() with 2 entries -> should fail
  expect_error(
    getGoDecisions(
      analyses_list   = analyses_list,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = quote(c(TRUE, TRUE))
    ),
    "boundary_rules"
  )
})


test_that("succeeds when all scenarios have identical method_names", {
  # A normal successful call executes the â‘¨ assignment
  res <- getGoDecisions(
    analyses_list   = analyses_list,
    cohort_names    = c("p_1","p_2","p_3"),
    evidence_levels = c(0.5, 0.5, 0.8),
    boundary_rules  = quote(c(x[1] > 0.1, x[2] < 0.6, x[3] < 0.9))
  )
  expect_s3_class(res, "decision_list")
})

test_that("fails when scenarios were analysed with different methods", {
  # Construct a second scenario by duplicating the first, then mutate method_names
  bad <- analyses_list
  bad$scenario_2 <- bad$scenario_1
  bad$scenario_2$analysis_parameters$method_names <-
    rev(bad$scenario_2$analysis_parameters$method_names)  # make it non-identical
  
  expect_error(
    getGoDecisions(
      analyses_list   = bad,
      cohort_names    = c("p_1","p_2","p_3"),
      evidence_levels = c(0.5, 0.5, 0.8),
      boundary_rules  = quote(c(x[1] > 0.1, x[2] < 0.6, x[3] < 0.9))
    ),
    "analysed with different methods"
  )
})


# Tests for getGoProbabilities -------------------------------------------------

scenarios_list <- simulateScenarios(
  n_subjects_list     = list(c(10, 20)),
  response_rates_list = list(rep(0.9, 2)),
  n_trials            = 10
)

analyses_list <- performAnalyses(
  scenario_list      = scenarios_list,
  target_rates       = rep(0.5, 2),
  n_mcmc_iterations  = 100
)
  
go_decisions_list <- getGoDecisions(
    analyses_list       = analyses_list,
    cohort_names        = c("p_1", "p_2"),
    evidence_levels     = c(0.5, 0.8),
    boundary_rules      = quote(c(x[1] > 0.8, x[2] > 0.6))
  )
  
nogo_decisions_list <- getGoDecisions(
    analyses_list       = analyses_list,
    cohort_names        = c("p_1", "p_2"),
    evidence_levels     = c(0.5, 0.8),
    boundary_rules      = quote(c(x[1] < 0.5, x[2] < 0.3))
  )

test_that("returns correct structure for Go-only decisions", {
  probs <- getGoProbabilities(go_decisions_list)
  expect_type(probs, "list")
  expect_true(all(sapply(probs, is.list)))
  expect_true(all(sapply(probs[[1]], function(x) "Go" %in% rownames(x))))
})

test_that("returns correct structure for Go and NoGo decisions", {
  probs <- getGoProbabilities(go_decisions_list, nogo_decisions_list)
  expect_true(all(sapply(probs[[1]], function(x) all(c("Go", "Consider", "NoGo") %in% rownames(x)))))
})

test_that("probabilities sum to 1 when NoGo decisions provided", {
  probs <- getGoProbabilities(go_decisions_list, nogo_decisions_list)
  sums <- sapply(probs[[1]], function(x) colSums(x))
  expect_true(all(abs(sums - 1) < 1e-6))
})

test_that("throws error for invalid go_decisions_list class", {
  expect_error(getGoProbabilities(list()), "go_decisions_list")
})

test_that("throws error for invalid nogo_decisions_list class", {
  expect_error(getGoProbabilities(go_decisions_list, list()), "decision_list")
})

test_that("throws error if dimensions mismatch between Go and NoGo lists", {
  bad_nogo <- nogo_decisions_list
  bad_nogo[[1]]$decisions_list[[1]] <- bad_nogo[[1]]$decisions_list[[1]][, -1]
  expect_error(getGoProbabilities(go_decisions_list, bad_nogo), "decision_list dimensions")
})

test_that("throws error if both Go and NoGo decisions are TRUE for same cohort", {
  overlap_go <- go_decisions_list
  overlap_nogo <- nogo_decisions_list
  overlap_go[[1]]$decisions_list[[1]][, 2] <- TRUE
  overlap_nogo[[1]]$decisions_list[[1]][, 2] <- TRUE
  expect_error(getGoProbabilities(overlap_go, overlap_nogo), "both go and nogo decisions")
})
