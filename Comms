#' Bin rows of a matrix column-wise and compute representative (median) per bin-group
#'
#' @param mat numeric matrix, rows = trials, cols = cohorts/statistics (e.g., sample means).
#' @param bin_breaks either:
#'   - a named list of numeric breaks vectors per column (names must match colnames(mat)), or
#'   - a single numeric vector of breaks (used for all columns).
#' @param nbins optional integer; if provided and bin_breaks is NULL, equal-width
#'   breaks are generated per column as seq(min, max, length.out = nbins + 1).
#' @param use_median logical; if TRUE (default) use column-wise median as representative;
#'   if FALSE, use column-wise mean.
#'
#' @return a list with:
#'   - groups: data.frame with representative values per group (one row per unique bin signature),
#'              plus `signature` and `n_members`.
#'   - map:    data.frame mapping each original row to its `signature` and integer `group_id`.
#'   - breaks: the list of breaks actually used per column.
#'
getUniqueRowsNormal <- function(mat, bin_breaks = NULL, nbins = NULL, use_median = TRUE) {
  stopifnot(is.matrix(mat), is.numeric(mat))
  n_cols <- ncol(mat)
  coln   <- colnames(mat) %||% paste0("c_", seq_len(n_cols))
  
  # Helper: coalesce-like for NULL
  `%||%` <- function(a, b) if (!is.null(a)) a else b
  
  # Normalize/construct breaks per column
  build_breaks <- function(mat, bin_breaks, nbins) {
    if (!is.null(bin_breaks)) {
      if (is.list(bin_breaks)) {
        # Recycle or reorder by column names if needed
        if (is.null(names(bin_breaks))) {
          # assume order corresponds to columns
          if (length(bin_breaks) != ncol(mat))
            stop("bin_breaks list length must match ncol(mat) or be named.")
          br <- bin_breaks
        } else {
          # named; align to column names
          if (!all(coln %in% names(bin_breaks)))
            stop("All column names of mat must exist in names(bin_breaks).")
          br <- bin_breaks[coln]
        }
      } else if (is.numeric(bin_breaks)) {
        # same breaks for all columns
        br <- rep(list(bin_breaks), ncol(mat))
        names(br) <- coln
      } else {
        stop("'bin_breaks' must be a list of numeric vectors or a numeric vector.")
      }
    } else {
      # auto-generate equal-width breaks per column using nbins
      if (is.null(nbins) || length(nbins) != 1L || !is.numeric(nbins) || nbins < 1)
        stop("Provide either 'bin_breaks' or a positive integer 'nbins'.")
      br <- lapply(seq_len(ncol(mat)), function(j) {
        r <- range(mat[, j], finite = TRUE)
        if (r[1] == r[2]) r <- r + c(-0.5, 0.5)  # widen degenerate ranges
        seq(from = r[1], to = r[2], length.out = nbins + 1L)
      })
      names(br) <- coln
    }
    br
  }
  
  brks <- build_breaks(mat, bin_breaks, nbins)
  
  # Bin each column -> integer codes
  bin_col <- function(x, breaks) {
    cut(x, breaks = breaks, include.lowest = TRUE, labels = FALSE)
  }
  bin_codes <- mapply(function(j, nm) bin_col(mat[, j], brks[[nm]]),
                      j = seq_len(n_cols), nm = coln, SIMPLIFY = FALSE)
  bin_codes <- as.data.frame(bin_codes, check.names = FALSE)
  names(bin_codes) <- coln
  
  # Signature per row (bin-combination)
  signature <- apply(bin_codes, 1L, function(v) paste(v, collapse = "-"))
  
  # Split row indices by signature
  groups_idx <- split(seq_len(nrow(mat)), signature)
  group_keys <- names(groups_idx)
  
  # Representative vector per group (median or mean)
  rep_fun <- if (use_median) stats::median else base::mean
  reps <- lapply(groups_idx, function(idx) {
    apply(mat[idx, , drop = FALSE], 2L, rep_fun, na.rm = TRUE)
  })
  reps_mat <- do.call(rbind, reps)
  colnames(reps_mat) <- coln
  
  groups_df <- data.frame(
    reps_mat,
    signature = group_keys,
    n_members = vapply(groups_idx, length, integer(1)),
    row.names = NULL,
    check.names = FALSE
  )
  
  # Map each original row to its group
  group_id <- match(signature, groups_df$signature)
  map_df <- data.frame(
    row_index = seq_len(nrow(mat)),
    signature = signature,
    group_id  = group_id,
    stringsAsFactors = FALSE
  )
  
  list(
    groups = groups_df,
    map    = map_df,
    breaks = brks
  )
}


#' Create unique trial groups for continuous outcomes using binning on sample means
#'
#' Expects each scenario to have `trials[[t]]$y_list$c_k` with numeric vectors of outcomes.
#'
#' @param scenario_list list of scenarios (as per your getScenarioNormal() output).
#' @param bin_breaks see getUniqueRowsNormal(); either list of breaks per cohort or one vector for all.
#'                   You can also pass a named list like list(c_1 = ..., c_2 = ..., c_3 = ...)
#'                   to use different bins per cohort.
#' @param nbins optional integer; used only if bin_breaks is NULL to auto-generate equal-width bins.
#' @param use_median logical; median (default) or mean as representative within each bin-group.
#'
#' @return a list with:
#'   - unique_trials: data.frame of representative means per unique bin-group +
#'                    `signature` and `n_members`.
#'   - map:           data.frame mapping each (scenario_index, trial_index) to its group.
#'   - breaks:        list of breaks used per cohort.
#'
getUniqueTrialsNormal <- function(scenario_list, bin_breaks = NULL, nbins = NULL, use_median = TRUE) {
  stopifnot(is.list(scenario_list), length(scenario_list) >= 1L)
  
  # Extract means per trial x cohort + keep indices
  trial_means <- list()
  index_tbl   <- list()
  r <- 1L
  
  for (s in seq_along(scenario_list)) {
    trials <- scenario_list[[s]]$trials
    stopifnot(is.list(trials), length(trials) >= 1L)
    
    for (t in seq_along(trials)) {
      yl <- trials[[t]]$y_list
      stopifnot(is.list(yl), length(yl) >= 1L)
      
      # ensure cohort order via names; fall back to natural order
      coh_names <- names(yl) %||% paste0("c_", seq_along(yl))
      means_vec <- vapply(yl, mean, numeric(1))
      names(means_vec) <- coh_names
      
      trial_means[[r]] <- means_vec
      index_tbl[[r]] <- data.frame(
        scenario_index = s,
        trial_index    = t,
        stringsAsFactors = FALSE
      )
      r <- r + 1L
    }
  }
  
  # Bind into a matrix with consistent column order
  all_cohorts <- names(trial_means[[1]])
  if (!all(vapply(trial_means, function(v) identical(names(v), all_cohorts), logical(1)))) {
    # Align columns if some trials missed names or order differs
    all_cohorts <- unique(unlist(lapply(trial_means, names), use.names = FALSE))
    trial_means <- lapply(trial_means, function(v) {
      v[all_cohorts] %||% setNames(rep(NA_real_, length(all_cohorts)), all_cohorts)
    })
  }
  mat <- do.call(rbind, trial_means)
  rownames(mat) <- NULL
  colnames(mat) <- all_cohorts
  
  # Delegate to binning function
  res <- getUniqueRowsNormal(mat, bin_breaks = bin_breaks, nbins = nbins, use_median = use_median)
  
  # Build a map with scenario/trial indices
  idx_df <- do.call(rbind, index_tbl)
  map <- cbind(idx_df, res$map[, c("signature", "group_id")], row.names = NULL)
  
  list(
    unique_trials = res$groups,  # representative (median) means per group
    map           = map,         # mapping back to each (scenario, trial)
    breaks        = res$breaks
  )
}
``

loadAnalysesNormal <- function(
    scenario_numbers,
    analysis_numbers = rep(1, length(scenario_numbers)),
    load_path        = tempdir()
) {
  loadAnalyses(
    scenario_numbers = scenario_numbers,
    analysis_numbers = analysis_numbers,
    load_path        = load_path
  )
}

# Mapping Helpers --------------------------------------------------------------
.bin_values <- function(x, breaks) {
  # returns integer bin index per value
  cut(x, breaks = breaks, include.lowest = TRUE, labels = FALSE)
}

.trial_means_from_y_list <- function(y_list) {
  # y_list is a named list: c_1, c_2, ...
  # returns a named numeric vector of means per cohort
  sapply(y_list, mean)
}

.compute_signatures_for_scenario <- function(scenario, bin_breaks) {
  # scenario: one element of scenario_list
  # bin_breaks: list(c_1=..., c_2=..., ...)
  n_trials <- length(scenario$trials)
  stopifnot(n_trials > 0)
  
  # Ensure bin_breaks names align with y_list names
  y_names <- names(scenario$trials[[1]]$y_list)
  if (is.null(names(bin_breaks))) {
    stop("bin_breaks must be a named list with names matching y_list names (e.g., c_1, c_2, ...).")
  }
  if (!all(y_names %in% names(bin_breaks))) {
    stop("bin_breaks names must cover all cohorts in y_list: missing ",
         paste(setdiff(y_names, names(bin_breaks)), collapse = ", "))
  }
  
  signatures <- character(n_trials)
  
  for (t in seq_len(n_trials)) {
    means <- .trial_means_from_y_list(scenario$trials[[t]]$y_list)
    # order breaks to match means by cohort names
    breaks_ordered <- bin_breaks[names(means)]
    bins <- mapply(.bin_values, x = as.list(means), breaks = breaks_ordered)
    signatures[t] <- paste(bins, collapse = "-")
  }
  
  signatures
}

mapUniqueTrialsNormal <- function(
    scenario_list,
    method_quantiles_list,         # named list: method -> named list by signature -> quantiles
    bin_breaks,                    # named list per cohort; names must match y_list names
    applicable_previous_trials = TRUE
) {
  method_names     <- names(method_quantiles_list)  # e.g., "normal"
  scenario_numbers <- sapply(scenario_list, function(x) x$scenario_number)
  
  scenario_method_quantiles_list <- vector("list", length(scenario_list))
  
  for (k in seq_along(scenario_list)) {
    sc <- scenario_list[[k]]
    
    # Determine #trials consistently
    n_trials <- length(sc$trials)
    if (is.null(n_trials) || n_trials == 0L) {
      stop("scenario_list[[", k, "]] has no trials.")
    }
    
    # Previous analyses handling (kept consistent with your original logic)
    if (applicable_previous_trials &&
        !is.null(sc$previous_analyses$post_quantiles)) {
      
      scenario_go_flags <- sc$previous_analyses$go_decisions[, 1] > 0
      scenario_method_quantiles <- sc$previous_analyses$post_quantiles
      
      # If stored structure didn't include all methods, ensure they exist
      if (is.null(names(scenario_method_quantiles))) {
        names(scenario_method_quantiles) <- method_names
      } else {
        missing_methods <- setdiff(method_names, names(scenario_method_quantiles))
        for (mm in missing_methods) scenario_method_quantiles[[mm]] <- vector("list", n_trials)
      }
      
    } else {
      scenario_go_flags <- rep(TRUE, n_trials)
      scenario_method_quantiles <- vector("list", length(method_names))
      names(scenario_method_quantiles) <- method_names
      # Pre-allocate list per method per trial
      for (mm in method_names) scenario_method_quantiles[[mm]] <- vector("list", n_trials)
    }
    
    # Compute signatures for ALL trials in this scenario
    signatures <- .compute_signatures_for_scenario(sc, bin_breaks)
    
    # For trials flagged as "go", fill from lookup keyed by signature
    if (any(scenario_go_flags)) {
      idx <- which(scenario_go_flags)
      
      for (mm in method_names) {
        lookup <- method_quantiles_list[[mm]]  # named list by signature
        # Fill each trial
        for (ii in idx) {
          sig <- signatures[ii]
          if (!is.null(lookup[[sig]])) {
            scenario_method_quantiles[[mm]][[ii]] <- lookup[[sig]]
          } else {
            # Signature not found in lookup; leave as NULL/NA
            # (optional) message for diagnostics:
            # message("No result for method '", mm, "' and signature '", sig,
            #         "' in scenario ", scenario_numbers[k], ", trial ", ii, ".")
            scenario_method_quantiles[[mm]][[ii]] <- NULL
          }
        }
      }
    }
    
    scenario_method_quantiles_list[[k]] <- scenario_method_quantiles
  }
  
  names(scenario_method_quantiles_list) <- paste0("scenario_", scenario_numbers)
  scenario_method_quantiles_list
}

# ------------------------------------------------------------------------------

# --- bin helpers ---
bin_values <- function(x, breaks) {
  cut(x, breaks = breaks, include.lowest = TRUE, labels = FALSE)
}

trial_means_from_ylist <- function(y_list) {
  # y_list: named list c_1, c_2, ... each a numeric vector
  sapply(y_list, mean)
}

# --- build bin table across all scenarios/trials ---
computeTrialBinsNormal <- function(scenario_list, bin_breaks) {
  rows <- list()
  r <- 1L
  for (s in seq_along(scenario_list)) {
    trials <- scenario_list[[s]]$trials
    for (t in seq_along(trials)) {
      means <- trial_means_from_ylist(trials[[t]]$y_list)
      # allow bin_breaks as list named by cohort (c_1, c_2, ...)
      bins <- mapply(bin_values, x = means, breaks = bin_breaks, SIMPLIFY = TRUE)
      signature <- paste(bins, collapse = "-")
      rows[[r]] <- data.frame(
        scenario_index = s,
        trial_index    = t,
        signature      = signature,
        t(means),
        t(bins),
        row.names = NULL,
        check.names = FALSE
      )
      r <- r + 1L
    }
  }
  # Ensure stable ordering
  df <- do.call(rbind, rows)
  df[order(df$signature, df$scenario_index, df$trial_index), , drop = FALSE]
}

# --- pick one representative trial per signature ---
selectRepresentativesNormal <- function(bin_table) {
  # columns: scenario_index, trial_index, signature, means..., bins...
  mean_cols <- grep("^V\\d+$|^means|^c_\\d+$", names(bin_table), value = TRUE)
  # Fallback: take columns 4..(3 + n_cohorts) if names are generic
  if (length(mean_cols) == 0L) {
    mean_cols <- names(bin_table)[4:(3 + ncol(bin_table) %/% 2)]
  }
  split_idx <- split(seq_len(nrow(bin_table)), bin_table$signature)
  reps <- lapply(names(split_idx), function(sig) {
    idx <- split_idx[[sig]]
    M   <- as.matrix(bin_table[idx, mean_cols, drop = FALSE])
    med <- matrixStats::colMedians(M)
    d1  <- rowSums(abs(sweep(M, 2L, med, "-"))) # L1 distance to median mean vector
    i_min <- idx[which.min(d1)]
    data.frame(
      signature      = sig,
      rep_row_index  = i_min,
      scenario_index = bin_table$scenario_index[i_min],
      trial_index    = bin_table$trial_index[i_min],
      stringsAsFactors = FALSE
    )
  })
  do.call(rbind, reps)
}

# --- pack representative trials and build a lookup ---
buildRepInputsNormal <- function(scenario_list, representatives) {
  # representatives: data.frame(signature, scenario_index, trial_index)
  rep_trials <- vector("list", nrow(representatives))
  names(rep_trials) <- representatives$signature
  for (k in seq_len(nrow(representatives))) {
    s <- representatives$scenario_index[k]
    t <- representatives$trial_index[k]
    rep_trials[[k]] <- scenario_list[[s]]$trials[[t]]$y_list
  }
  rep_trials
}

# --- map each original (s,t) to rep_id (index in rep_trials) ---
buildSignatureIndex <- function(bin_table, representatives) {
  sig2rep <- setNames(seq_len(nrow(representatives)), representatives$signature)
  rep_id  <- unname(sig2rep[bin_table$signature])
  cbind(bin_table[, c("scenario_index", "trial_index", "signature")], rep_id = rep_id)
}

# runs JAGS once per representative y_list
getPostQuantilesNormal_fromRepTrials <- function(
    rep_trials, quantiles, j_parameters, j_model_file, j_data_fixed,
    calc_differences = NULL, n_mcmc_iterations = 1e4, method_name = "normal",
    save_path = NULL, save_trial = FALSE
) {
  # returns a list aligned with rep_trials (one element per unique signature)
  lapply(seq_along(rep_trials), function(k) {
    getPostQuantilesOfTrial(
      y_list            = rep_trials[[k]],
      j_data            = j_data_fixed,
      j_parameters      = j_parameters,
      j_model_file      = j_model_file,
      method_name       = method_name,
      quantiles         = quantiles,
      calc_differences  = calc_differences,
      n_mcmc_iterations = n_mcmc_iterations,
      save_path         = save_path,
      save_trial        = save_trial
    )
  })
}

mapByRepIdNormal <- function(scenario_list, method_quantiles_by_rep, signature_index) {
  # signature_index: data.frame(scenario_index, trial_index, signature, rep_id)
  # Return same shape as scenario_list: list per scenario -> list per trial -> quantiles
  out <- vector("list", length(scenario_list))
  for (s in seq_along(scenario_list)) {
    trials <- scenario_list[[s]]$trials
    out_s  <- vector("list", length(trials))
    idx_s  <- signature_index$scenario_index == s
    for (t in seq_along(trials)) {
      rep_id <- signature_index$rep_id[idx_s & signature_index$trial_index == t]
      out_s[[t]] <- method_quantiles_by_rep[[rep_id]]
    }
    out[[s]] <- out_s
  }
  out
}



performAnalysesNormal <- function(
    scenario_list,
    evidence_levels        = c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975),
    calc_differences       = NULL,
    n_mcmc_iterations      = 1e4,
    prior_parameters_normal= NULL,
    verbose                = TRUE
) {
  error_scenario_list <- simpleError(
    "Please provide an object of class 'scenario_list_normal' for 'scenario_list'")
  error_evidence_levels <- simpleError(
    "Please provide a vector of numerics in (0, 1) for the argument 'evidence_levels'")
  error_n_mcmc_iterations <- simpleError(
    "Please provide a positive integer for the argument 'n_mcmc_iterations'")
  error_verbose <- simpleError(
    "Please provide a logical for the argument 'verbose'")
  
  if (missing(scenario_list)) stop(error_scenario_list)
  if (!is.scenario_list_normal(scenario_list)) stop(error_scenario_list)
  
  if (!is.numeric.in.zero.one(evidence_levels)) stop(error_evidence_levels)
  if (!is.single.positive.wholenumber(n_mcmc_iterations)) stop(error_n_mcmc_iterations)
  if (!is.logical(verbose) || length(verbose) != 1L) stop(error_verbose)
  
  if (!is.null(calc_differences)) {
    calc_differences <- convertVector2Matrix(calc_differences)
  }
  
  quantiles <- sort(unique(round(
    1 - c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975, evidence_levels),
    9
  )))
  
  if (is.null(prior_parameters_normal)) {
    prior_parameters_normal <- getPriorParametersNormal()
  }
  
  prep         <- prepareAnalysisNormal(prior_parameters = prior_parameters_normal)
  j_parameters <- prep$j_parameters
  j_model_file <- prep$j_model_file
  j_data_fixed <- prep$j_data
  
  scenario_numbers <- sapply(scenario_list, function(x) x$scenario_number)
  
  
  # --- NEW: build bin index and representatives ---
  if (is.null(bin_breaks)) {
    # default: derive number of cohorts from first scenario
    n_cohorts <- length(scenario_list[[1]]$trials[[1]]$y_list)
    # crude default breaks; you should set this explicitly upstream
    bin_breaks <- rep(list(seq(-10, 10, by = 0.25)), n_cohorts)
    names(bin_breaks) <- paste0("c_", seq_len(n_cohorts))
  }
  
  bin_table        <- computeTrialBinsNormal(scenario_list, bin_breaks)
  representatives  <- selectRepresentativesNormal(bin_table)
  rep_trials       <- buildRepInputsNormal(scenario_list, representatives)
  signature_index  <- buildSignatureIndex(bin_table, representatives)
  
  if (verbose) {
    message(
      format(Sys.time(), "%d-%b-%Y"),
      " Performing Analyses (normal endpoint)"
    )
    message(
      "   Analyzing ",
      length(scenario_numbers), " scenario",
      ifelse(length(scenario_numbers) == 1, "", "s"),
      " (", length(rep_trials), " unique bin group",
      ifelse(length(rep_trials) == 1, "", "s"), ")"
    )
  }
  
  if (verbose) {
    start_time <- Sys.time()
    message("   Running bhm_normal model on representative trials ...")
  }
  
  # --- CHANGED: run per representative trial (one per unique signature) ---
  method_quantiles_by_rep <- getPostQuantilesNormal_fromRepTrials(
    rep_trials        = rep_trials,
    quantiles         = quantiles,
    j_parameters      = j_parameters,
    j_model_file      = j_model_file,
    j_data_fixed      = j_data_fixed,
    calc_differences  = calc_differences,
    n_mcmc_iterations = n_mcmc_iterations
  )
  
  if (verbose) {
    message(
      "       finished after ",
      round(Sys.time() - start_time, 1), " ",
      units(Sys.time() - start_time), "."
    )
  }
  
  # --- CHANGED: map back by (scenario,trial) -> rep_id ---
  if (verbose) {
    start_time <- Sys.time()
    message("   Processing scenarios (mapping bin results) ...")
  }
  
  scenario_method_quantiles_list <- mapByRepIdNormal(
    scenario_list             = scenario_list,
    method_quantiles_by_rep   = method_quantiles_by_rep,
    signature_index           = signature_index
  )
  
  if (verbose) {
    message(
      "       finished after ",
      round(Sys.time() - start_time, 1), " ",
      units(Sys.time() - start_time), "."
    )
  }
  
  # --- output unchanged below, except we plug in the mapped results ---
  analyses_list        <- vector("list", length(scenario_numbers))
  names(analyses_list) <- paste0("scenario_", scenario_numbers)
  
  for (s in seq_along(scenario_numbers)) {
    analyses_list[[s]] <- list(
      quantiles_list      = list(normal = scenario_method_quantiles_list[[s]]),
      scenario_data       = scenario_list[[s]],
      analysis_parameters = list(
        quantiles               = quantiles,
        evidence_levels         = evidence_levels,
        method_names            = "normal",
        prior_parameters_normal = prior_parameters_normal,
        n_mcmc_iterations       = n_mcmc_iterations,
        bin_breaks              = bin_breaks  # <-- record for reproducibility
      )
    )
  }
  
  class(analyses_list) <- "analysis_list_normal"
  analyses_list
}
