doFuture::registerDoFuture()
future::plan(future::multisession)

## compute overall Go probability for (n, p_true, gamma)
## ------------------------------------------------------------------

go_prob_overall <- function(n,
                            p_true_vec,
                            p_beta_vec,
                            gamma,
                            overall_min_gos = 1,
                            n_trials,
                            method_name = "berry"
) {
  
  scen <- simulateScenarios(
    n_subjects_list     = list(c(n, n)),        
    response_rates_list = list(p_true_vec),
    n_trials            = n_trials
  )
  
  analyses <- performAnalyses(
    scenario_list      = scen,
    evidence_levels    = seq(0.5, 0.95, by = 0.05),
    target_rates       = p_beta_vec,
    method_names       = method_name,
    n_mcmc_iterations  = 100,
    verbose            = FALSE
  )
  
  decisions <- getGoDecisions(
    analyses_list   = analyses,
    cohort_names    = c("p_1", "p_2"),
    evidence_levels = c(gamma, gamma),                
    boundary_rules  = quote(c(x[1] > p_beta_vec[1],
                              x[2] > p_beta_vec[2])),
    overall_min_gos = overall_min_gos
  )
  
  go_probs_list <- getGoProbabilities(decisions)
  go_mat <- go_probs_list[[method_name]][["scenario_1"]]
  
  go_mat["Go", "overall"]
}


## Grid search: find (n, gamma) that satisfy type I & power constraints
## ------------------------------------------------------------------

# Design settings
p0           <- c(0.30, 0.30)    # null true response rate
p1           <- c(0.60, 0.60)    # alternative true response rate
p_beta_vec   <- c(0.30, 0.30)    # clinical boundary
type_1_error <- 0.10             # allowed type I error
power_min    <- 0.80             # required power
n_trials_oc  <- 1000             # number of simulated trials per (n, gamma) scenario

# Search grid:
n_grid     <- c(20, 30, 40, 50, 60, 80, 100)          # candidate sample sizes
gamma_grid <- seq(0.5, 0.95, by = 0.05)               # candidate evidence levels

oc_results <- expand.grid(
  n     = n_grid,
  gamma = gamma_grid
)

oc_results$type_1_error_hat <- NA_real_
oc_results$power_hat <- NA_real_

set.seed(2026)

for (i in seq_len(nrow(oc_results))) {
  n_i     <- oc_results$n[i]
  gamma_i <- oc_results$gamma[i]
  
  # Type I error under p0
  oc_results$type_1_error_hat[i] <- go_prob_overall(
    n            = n_i,
    p_true_vec   = p0,
    p_beta_vec   = p_beta_vec,
    gamma        = gamma_i,
    n_trials     = n_trials_oc,
  )
  
  # Power under p1
  oc_results$power_hat[i] <- go_prob_overall(
    n            = n_i,
    p_true_vec   = p1,
    p_beta_vec   = p_beta_vec,
    gamma        = gamma_i,
    n_trials     = n_trials_oc,
  )
}

# designs that satisfy the constraints
oc_results$feasible <- with(oc_results, 
                            type_1_error_hat <= type_1_error 
                            & power_hat >= power_min
)

oc_results

feasible_designs <- subset(oc_results, feasible)

md <- as.data.frame(oc_results)
head(md)
as.numeric(md$feasible)

plot(x= md$n, y= md$gamma, type = "p", xlab = "sample size", ylab = "evidence level", col = ifelse(as.numeric(md$feasible) == 0,'red','green'))


