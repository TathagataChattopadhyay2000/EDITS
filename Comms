getUniqueTrials <- function (
    
  scenario_list,
  endpoint    = NULL,
  nbins       = 5,
  bin_breaks  = NULL
  
) {
  
  if (is.null(endpoint)) {
    endpoint <- if (!is.null(scenario_list[[1]]$endpoint)) scenario_list[[1]]$endpoint else "binary"
  }
  
  all_scenarios_n_subjects  <- do.call(rbind, lapply(scenario_list, function (x) x$n_subjects))
  all_scenarios_overall_gos <- do.call(rbind, lapply(scenario_list, function (x)
    x$previous_analyses$go_decisions))[, 1]
  
  if (endpoint == "binary") {
    
    all_scenarios_n_responders <- do.call(rbind, lapply(scenario_list, function (x) x$n_responders))
    
    out <- getUniqueRows(cbind(
      all_scenarios_n_responders,
      all_scenarios_n_subjects,
      go_flag = all_scenarios_overall_gos
    ))
    
    return(out)
    
  } else {
    
    all_scenarios_y <- do.call(rbind, lapply(scenario_list, function (x) x$y))
    n_cohorts <- ncol(all_scenarios_y)
    cohort_names <- colnames(all_scenarios_y)
    if (is.null(cohort_names)) cohort_names <- paste0("y_", seq_len(n_cohorts))
    
    ## 1) build breaks per cohort
    if (is.null(bin_breaks)) {
      
      if (!is.numeric(nbins) || length(nbins) != 1L || nbins < 1) {
        stop("For endpoint = 'normal', 'nbins' must be a positive integer if 'bin_breaks' is NULL")
      }
      
      breaks <- lapply(seq_len(n_cohorts), function (j) {
        r <- range(all_scenarios_y[, j], finite = TRUE)
        if (!all(is.finite(r))) stop("Non-finite y values found; cannot create bins.")
        if (r[1L] == r[2L]) r <- r + c(-0.5, 0.5)
        r <- r + c(-1e-8, 1e-8)  ## pad for cut() edge safety
        seq(from = r[1L], to = r[2L], length.out = nbins + 1L)
      })
      names(breaks) <- cohort_names
      
    } else {
      
      if (!is.list(bin_breaks)) stop("'bin_breaks' must be a list or NULL")
      if (!all(cohort_names %in% names(bin_breaks))) {
        stop(paste0(
          "All cohorts must appear in 'bin_breaks'. Missing: ",
          paste(setdiff(cohort_names, names(bin_breaks)), collapse = ", ")
        ))
      }
      breaks <- bin_breaks[cohort_names]
      
    }
    
    ## 2) bin codes for every trial/cohort
    bin_codes <- matrix(NA_integer_, nrow(all_scenarios_y), n_cohorts)
    colnames(bin_codes) <- cohort_names
    
    for (j in seq_len(n_cohorts)) {
      bin_codes[, j] <- cut(
        all_scenarios_y[, j],
        breaks         = breaks[[j]],
        include.lowest = TRUE,
        labels         = FALSE
      )
    }
    
    ## 3) representative per bin = mean of samples in that bin (per cohort)
    bin_means <- vector("list", n_cohorts)
    names(bin_means) <- cohort_names
    
    for (j in seq_len(n_cohorts)) {
      bj <- breaks[[j]]
      mids <- (bj[-length(bj)] + bj[-1L]) / 2  ## fallback for empty bins
      
      reps <- rep(NA_real_, length(bj) - 1L)
      for (b in seq_len(length(reps))) {
        vals <- all_scenarios_y[bin_codes[, j] == b, j]
        if (length(vals) > 0) reps[b] <- mean(vals)
        if (is.na(reps[b]))   reps[b] <- mids[b]
      }
      bin_means[[j]] <- reps
    }
    
    ## 4) replace each trialâ€™s y by the bin representative (mean of samples in bin)
    y_rep <- matrix(NA_real_, nrow(all_scenarios_y), n_cohorts)
    colnames(y_rep) <- cohort_names
    
    for (j in seq_len(n_cohorts)) {
      y_rep[, j] <- bin_means[[j]][bin_codes[, j]]
    }
    
    out <- getUniqueRows(cbind(
      y_rep,
      all_scenarios_n_subjects,
      go_flag = all_scenarios_overall_gos
    ))
    
    ## attach binning info for consistent mapping
    keys_all    <- getHashKeys(cbind(y_rep, all_scenarios_n_subjects, go_flag = all_scenarios_overall_gos))
    keys_unique <- getHashKeys(out)
    group_id    <- match(keys_all, keys_unique)
    group_sizes <- as.integer(tabulate(group_id, nbins = nrow(out)))
    
    attr(out, "bin_breaks")  <- breaks
    attr(out, "bin_means")   <- bin_means
    attr(out, "group_sizes") <- group_sizes
    
    return(out)
    
  }
  
}


mapUniqueTrials <- function (
    
  scenario_list,
  method_quantiles_list,
  trials_unique_calc,
  applicable_previous_trials,
  endpoint   = NULL,
  bin_breaks = NULL,
  bin_means  = NULL
  
) {
  
  if (is.null(endpoint)) {
    endpoint <- if (!is.null(scenario_list[[1]]$endpoint)) scenario_list[[1]]$endpoint else "binary"
  }
  
  if (endpoint == "normal") {
    if (is.null(bin_breaks)) bin_breaks <- attr(trials_unique_calc, "bin_breaks")
    if (is.null(bin_means))  bin_means  <- attr(trials_unique_calc, "bin_means")
    if (is.null(bin_breaks) || is.null(bin_means)) {
      stop("For endpoint = 'normal', provide 'bin_breaks' and 'bin_means' or pass trials_unique_calc with these attributes")
    }
  }
  
  method_names     <- names(method_quantiles_list)
  scenario_numbers <- sapply(scenario_list, function (x) x$scenario_number)
  
  hash_keys        <- getHashKeys(trials_unique_calc)
  hash_tables_list <- vector(mode = "list", length = length(method_quantiles_list))
  
  for (n in seq_along(hash_tables_list)) {
    hash_tables_list[[n]] <- createHashTable(hash_keys, method_quantiles_list[[n]])
  }
  
  exported_stuff <- c("convertVector2Matrix")
  "%do%" <- foreach::"%do%"
  
  scenario_method_quantiles_list <- foreach::foreach(
    k = seq_along(scenario_numbers),
    .verbose  = FALSE,
    .export   = exported_stuff
  ) %do% {
    
    if (endpoint == "binary") {
      
      scenario_data_matrix <- cbind(
        scenario_list[[k]]$n_responders,
        scenario_list[[k]]$n_subjects
      )
      
    } else {
      
      y <- scenario_list[[k]]$y
      n_cohorts <- ncol(y)
      cohort_names <- colnames(y)
      if (is.null(cohort_names)) cohort_names <- paste0("y_", seq_len(n_cohorts))
      
      y_rep <- matrix(NA_real_, nrow(y), n_cohorts)
      colnames(y_rep) <- cohort_names
      
      for (j in seq_len(n_cohorts)) {
        bks <- bin_breaks[[cohort_names[j]]]
        ids <- cut(y[, j], breaks = bks, include.lowest = TRUE, labels = FALSE)
        y_rep[, j] <- bin_means[[cohort_names[j]]][ids]
      }
      
      scenario_data_matrix <- cbind(
        y_rep,
        scenario_list[[k]]$n_subjects
      )
      
    }
    
    if (applicable_previous_trials) {
      scenario_go_flags         <- scenario_list[[k]]$previous_analyses$go_decisions[, 1] > 0
      scenario_method_quantiles <- scenario_list[[k]]$previous_analyses$post_quantiles
    } else {
      scenario_go_flags         <- rep(TRUE, length = nrow(scenario_data_matrix))
      scenario_method_quantiles <- vector(mode = "list", length = length(method_names))
      names(scenario_method_quantiles) <- method_names
    }
    
    if (any(scenario_go_flags)) {
      
      scenario_data_matrix_go <- convertVector2Matrix(scenario_data_matrix[scenario_go_flags, ])
      search_keys             <- getHashKeys(scenario_data_matrix_go)
      
      for (n in seq_along(method_names)) {
        scenario_method_quantiles[[method_names[n]]][scenario_go_flags] <-
          getHashValues(search_keys, hash_tables_list[[n]])
      }
    }
    
    return(scenario_method_quantiles)
  }
  
  names(scenario_method_quantiles_list) <- paste0("scenario_", scenario_numbers)
  return(scenario_method_quantiles_list)
}
