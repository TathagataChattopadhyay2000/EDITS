performAnalyses <- function (
  
  scenario_list,
  evidence_levels       = c(0.025, 0.05, 0.5, 0.8, 0.9, 0.95, 0.975),
  
  method_names          = c("berry", "exnex", "exnex_adj", "pooled", "stratified"),
  target_rates          = NULL,
  prior_parameters_list = NULL,
  
  calc_differences      = NULL,
  
  n_mcmc_iterations     = 1e4,
  n_cores               = 1,
  seed                  = 1,
  verbose               = TRUE
  
) {
  ## ---------------------------------------------------------------------------
  ## Deprecation warnings for old arguments
  ## ---------------------------------------------------------------------------
  warning_n_cores <- "The argument 'n_cores' is deprecated as of version 0.9.3."
  warning_seed    <- "The argument 'seed' is deprecated as of version 0.9.3."
  
  if (!missing(n_cores)) warning(warning_n_cores)
  if (!missing(seed))    warning(warning_seed)
  
  ## ---------------------------------------------------------------------------
  ## Basic presence & class checks
  ## ---------------------------------------------------------------------------
  
  # scenario_list must be supplied and have the correct class
  checkmate::assertClass(
    scenario_list,
    "scenario_list",
    .var.name = "scenario_list"
  )
  
  # evidence_levels: numeric, all in (0, 1)
  checkmate::assertNumeric(
    evidence_levels,
    any.missing = FALSE,
    .var.name   = "evidence_levels"
  )
  checkmate::assertTRUE(
    all(evidence_levels > 0 & evidence_levels < 1),
    .var.name = "evidence_levels must be in (0, 1)"
  )
  
  # method_names: character and must be one of the allowed methods
  checkmate::assertCharacter(
    method_names,
    any.missing = FALSE,
    min.len     = 1,
    .var.name   = "method_names"
  )
  method_names <- match.arg(
    method_names,
    choices    = c("berry", "exnex", "exnex_adj", "pooled", "stratified"),
    several.ok = TRUE
  )
  
  # target_rates: either NULL or numeric in (0, 1)
  if (!is.null(target_rates)) {
    checkmate::assertNumeric(
      target_rates,
      any.missing = FALSE,
      .var.name   = "target_rates"
    )
    checkmate::assertTRUE(
      all(target_rates > 0 & target_rates < 1),
      .var.name = "target_rates must be in (0, 1)"
    )
  }
  
  # prior_parameters_list: either NULL or object with class 'prior_parameters_list'
  if (!is.null(prior_parameters_list)) {
    checkmate::assertClass(
      prior_parameters_list,
      "prior_parameters_list",
      .var.name = "prior_parameters_list"
    )
  }
  
  ## ---------------------------------------------------------------------------
  ## Logical constraints: target_rates vs methods / priors
  ## ---------------------------------------------------------------------------
  
  if (is.null(target_rates)) {
    
    # If target_rates are missing, berry and exnex_adj are not allowed
    checkmate::assertTRUE(
      !any(c("berry", "exnex_adj") %in% method_names),
      .var.name = "target_rates must be provided when using 'berry' or 'exnex_adj'"
    )
    
    # Need at least one of prior_parameters_list or target_rates
    checkmate::assertTRUE(
      !is.null(prior_parameters_list),
      .var.name = "provide at least one of 'prior_parameters_list' or 'target_rates'"
    )
    
  } else {
    # If target_rates is present, its length must match the number of cohorts
    n_coh <- ncol(scenario_list[[1]]$n_subjects)
    checkmate::assertTRUE(
      identical(length(target_rates), n_coh),
      .var.name = "length(target_rates) must match number of cohorts"
    )
  }
  
  ## ---------------------------------------------------------------------------
  ## Logical constraints: prior_parameters_list content per method
  ## ---------------------------------------------------------------------------
  
  if (!is.null(prior_parameters_list)) {
    
    # All methods used must have entries in prior_parameters_list
    checkmate::assertTRUE(
      all(method_names %in% names(prior_parameters_list)),
      .var.name = "all method_names must appear in names(prior_parameters_list)"
    )
    
    # For exnex / exnex_adj / stratified, per-cohort prior lengths must
    # match the number of cohorts in scenario_list
    n_coh <- ncol(scenario_list[[1]]$n_subjects)
    
    inconsistent_cohorts <- any(
      sapply(
        intersect(names(prior_parameters_list),
                  c("exnex", "exnex_adj", "stratified")),
        function(name) {
          max(sapply(prior_parameters_list[[name]], length)) != n_coh
        }
      )
    )
    
    checkmate::assertFALSE(
      inconsistent_cohorts,
      .var.name = "number of cohorts in prior_parameters_list must match scenario_list"
    )
  }
  
  ## ---------------------------------------------------------------------------
  ## calc_differences: NULL or (length-2 vector OR matrix with 2 columns) of
  ## positive integer indices <= n_cohorts_min
  ## ---------------------------------------------------------------------------
  
  n_cohorts_min <- min(sapply(scenario_list, function(x) ncol(x$n_responders)))
  
  if (!is.null(calc_differences)) {
    
    checkmate::assertNumeric(
      calc_differences,
      any.missing = FALSE,
      .var.name   = "calc_differences"
    )
    
    is_len2   <- identical(length(calc_differences), 2L)
    has_2cols <- !is.null(dim(calc_differences)) &&
      identical(ncol(calc_differences), 2L)
    
    checkmate::assertTRUE(
      is_len2 || has_2cols,
      .var.name = "calc_differences must be length-2 vector or matrix with 2 columns"
    )
    
    checkmate::assertIntegerish(
      calc_differences,
      lower       = 1,
      any.missing = FALSE,
      .var.name   = "calc_differences"
    )
    
    checkmate::assertTRUE(
      max(calc_differences) <= n_cohorts_min,
      .var.name = "calc_differences indices must not exceed number of cohorts"
    )
  }
  rm(n_cohorts_min)
  
  ## ---------------------------------------------------------------------------
  ## n_mcmc_iterations & verbose
  ## ---------------------------------------------------------------------------
  
  # If n_mcmc_iterations exists in .GlobalEnv and argument is missing, reuse it
  if ("n_mcmc_iterations" %in% ls(envir = .GlobalEnv) && missing(n_mcmc_iterations)) {
    n_mcmc_iterations <- get("n_mcmc_iterations", envir = .GlobalEnv)
  }
  
  checkmate::assertInt(
    n_mcmc_iterations,
    lower    = 1,
    .var.name = "n_mcmc_iterations"
  )
  
  checkmate::assertLogical(
    verbose,
    len         = 1L,
    any.missing = FALSE,
    .var.name   = "verbose"
  )
  
  ## ---------------------------------------------------------------------------
  ## Parallel backend check
  ## ---------------------------------------------------------------------------
  
  # Only need a parallel backend if there is at least one method that is not pooled/stratified
  if (!all(method_names %in% c("stratified", "pooled"))) {
    checkForParallelBackend()
  }
